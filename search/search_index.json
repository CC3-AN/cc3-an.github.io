{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenidos a CC-3 En cursos anteriores han aprendido a programar en un nivel bastante alto de abstracci\u00f3n. Ac\u00e1 nos concentraremos en la m\u00e1quina y c\u00f3mo esta ejecuta los programas que ustedes escriben. En este curso nos preocuparemos no tanto por el proceso de escribir un programa de computadora, sino m\u00e1s bien en c\u00f3mo la computadora ejecuta los programas. Es decir, el tema principal de este curso es la estructura de la m\u00e1quina: los circuitos electr\u00f3nicos, y las operaciones computacionales que estos circuitos llevan a cabo. Para concretizar estas ideas, vamos a estudiar con cierto detalle el ISA RISC-V. Usamos este ISA pues es m\u00e1s sencillo que otras familias, mientras que posee caracter\u00edsticas deseables como paralelismo.","title":"Proyectos"},{"location":"#bienvenidos-a-cc-3","text":"En cursos anteriores han aprendido a programar en un nivel bastante alto de abstracci\u00f3n. Ac\u00e1 nos concentraremos en la m\u00e1quina y c\u00f3mo esta ejecuta los programas que ustedes escriben. En este curso nos preocuparemos no tanto por el proceso de escribir un programa de computadora, sino m\u00e1s bien en c\u00f3mo la computadora ejecuta los programas. Es decir, el tema principal de este curso es la estructura de la m\u00e1quina: los circuitos electr\u00f3nicos, y las operaciones computacionales que estos circuitos llevan a cabo. Para concretizar estas ideas, vamos a estudiar con cierto detalle el ISA RISC-V. Usamos este ISA pues es m\u00e1s sencillo que otras familias, mientras que posee caracter\u00edsticas deseables como paralelismo.","title":"Bienvenidos a CC-3"},{"location":"labs/lab00/","text":"Lab 0 - Git y Representaci\u00f3n de N\u00fameros Objetivos Aprender git y crear cuenta de GitHub. Ganar m\u00e1s intuici\u00f3n para trabajar con n\u00fameros binarios. Lecturas P&H: 2.4 Ejercicio 1: Cuenta de GitHub Por favor lean las siguientes instrucciones cuidadosamente antes de seguir con el laboratorio. La mayor parte de los problemas que tienen los estudiantes durante este laboratorio se pueden prevenir siguiendo atentamente los pasos que se indican. Para este curso necesitaremos que utilicen git , un sistema de control de versiones distribuido . Los sistemas de control de versiones son las mejores herramientas para compartir y almacenar c\u00f3digo a comparaci\u00f3n de mandar correos con archivos adjuntos, utilizar memorias flash, o incluso compartir documentos mediante DropBox o Google Docs. Vamos a estar usando GitHub para tener repositorios privados en donde van a almacenar su c\u00f3digo remotamente. Si la oraci\u00f3n anterior no les dijo nada, no se preocupen, vamos a guiarlos en el proceso m\u00e1s adelante. Pero primero, necesitan crear una cuenta de GitHub . \u00bfPor qu\u00e9 GitHub? GitHub ahora le permite a todas las cuentas gratuitas tener repositorios privados ilimitados con algunas limitaciones que no van a ser ning\u00fan problema para nosotros. GitHub Onboarding Naveguen a la siguiente p\u00e1gina: github.com . Si no tienen una cuenta de GitHub todav\u00eda, creen una en el siguiente link . Preparaci\u00f3n Visiten este link . Aqu\u00ed encontrar\u00e1n todos los archivos necesarios para completar este laboratorio. En esta p\u00e1gina, encontrar\u00e1n un bot\u00f3n que dice \"Accept this assignment\". Al presionar este bot\u00f3n, se crear\u00e1 autom\u00e1ticamente un repositorio en Github llamado https://www.github.com/cc3-an/2021-lab00-git-<USUARIO> . Noten que el \"due\u00f1o\" de este repositorio es un usuario llamado cc3-an , y el usuario de ustedes es \u00fanicamente el sufijo del nombre del repo. De esta forma, nos encargamos de tener acceso siempre a su c\u00f3digo, en caso existan copias o cualquier otro tipo de trampa. Sepan de una vez que, si encontramos plagio en sus laboratorios, su nota ser\u00e1 AUTOM\u00c1TICAMENTE 0, sin posibilidad de cambiarla. De repetirse nuevamente este acontecimiento, el staff del curso organizar\u00e1 una reuni\u00f3n con ustedes y sus directores de carrera para contarles lo ocurrido y sancionarlos conforme al reglamento de la universidad. Despu\u00e9s de realizar esto, en la m\u00e1quina virtual (o sus propias computadoras) abran una terminal en el directorio que prefieran, y ejecuten el siguiente comando: 1 git clone https://github.com/cc3-an/2021-lab00-git-<SU USUARIO DE GITHUB> esto descargar\u00e1 en el directorio que escogieron todos los archivos base para este laboratorio. Configurando git Ahora que ya hemos creado nuestro repositorio, vamos a configurar git para que sepa qui\u00e9nes son. Abran una terminal Ctrl + Alt + T y ejecuten los siguientes comandos listados abajo, reemplazando NOMBRE con su nombre y apellido (entre comillas) y CORREO con la direcci\u00f3n de correo que utilizar\u00f3n para registrarse en GitHub. 1 git config --global user.name \"NOMBRE\" 1 git config --global user.email \"CORREO\" Ejercicio 2: git y Remotes Primero, algunas definiciones r\u00e1pidas: Un remote es la p\u00e1gina web host o servidor que va a almacenar su c\u00f3digo remotamente en vez de tener \u00fanicamente el c\u00f3digo de forma local en su propia computadora. Pueden pensar en esto de igual manera a como se almacena un archivo en DropBox o Google Drive pero con el poder que nos da git. Un branch es una secuencia (por aparte) de diferentes cambios a su c\u00f3digo. Pueden pensar en los branches como diferentes versiones de su c\u00f3digo, que en alg\u00fan punto fueron lo mismo. La siguiente figura muestra a que nos referimos como branches. A lo largo de este curso, estar\u00e1n trabajando en dos diferentes \" computadoras \" que generalmente tendran diferentes versiones de su c\u00f3digo en alg\u00fan tiempo. Estas dos son: su computadora personal y su remote de GitHub (sus repositorios privados de GitHub). Es esencial que entiendan la diferencia entre estas dos y como pueden compartir c\u00f3digo entre ellas. Su computadora personal es la que les servir\u00e1 para hacer todo el trabajo (laboratorios y proyectos) que necesiten hacer durante el curso, nada nuevo aqu\u00ed. Su cuenta de GitHub y los remotes les servir\u00e1n para muchos prop\u00f3sitos, pero la principal raz\u00f3n es para tener un backup o copia de respaldo, de tal manera que si algo malo le sucede a sus computadoras (esperamos no ), puedan recuperar su c\u00f3digo en vez de empezar de cero nuevamente. Conceptualmente, pueden pensar en los remotes de GitHub como otra computadora que \u00fanicamente almacena su c\u00f3digo y nada m\u00e1s. Siempre deben subir sus cambios a GitHub haciendo push al remote (es decir actualizando los archivos en GitHub) y tambi\u00e9n pueden descargar los cambios de GitHub haciendo pull (actualizando los archivos en su computadora personal). Haciendo push hacia GitHub Vamos a crear un archivo llamado hello.sh en la carpeta del laboratorio ejecutando el siguiente commando en la terminal: 1 echo 'echo \"Hola Mundo\"' > hello.sh Luego pueden correr el archivo en la terminal con bash hello.sh . En la terminal se imprimir\u00e1 Hola Mundo . Ahora utilicemos git para ver los archivos que todav\u00eda no han sido rastreados utilizando status : 1 git status Lo que producir\u00e1 lo siguiente: 1 2 3 4 5 6 7 8 9 10 On branch main No commits yet Untracked files: ( use \"git add <file>...\" to include in what will be committed ) hello.sh nothing added to commit but untracked files present ( use \"git add\" to track ) Esto es porque hemos creado un archivo nuevo llamado hello.sh y no lo hemos agregado. Podemos agregarlo y hacer commit: 1 2 3 4 git add hello.sh # agrega el archivo hello.sh para hacer commit git commit -m \"Mensaje del Commit\" # ingresa cualquier mensaje que quieras git branch # deberias de ver que solo existe el branch main y que estas en ella (*) git push -u origin main # Esto hace push de tu codigo hacia GitHub (lo puedes ver en GitHub ahora) El control de versiones git esta construido alrededor de commits , o checkpoints en el desarrollo de diferentes versiones/etapas de su c\u00f3digo. Para explicar los pasos de arriba un poco m\u00e1s: git add [archivo] le dir\u00e1 a git que han hecho cambios a ese archivo y que quieren que esos cambios se guarden en el siguiente commit (staging). git commit -m \"mensaje\" oficialmente guarda esos cambios que acaban de agregar, y crea un snapshot del contenido actual de todos los archivos en el repositorio. Ahora siempre van a tener la opci\u00f3n de revertir su c\u00f3digo hacia este commit. git push -u origin main manda todo el contenido del repositorio que est\u00e1 en el branch \"main\" al repositorio remoto \"origin\" (recuerden que agregamos el repositorio de GitHub \"lab0_git\" como remote y lo llamamos \"origin\"). Cuando estamos trabajando con git, si alguna vez no est\u00e1n seguros de algo, pero quieren asegurarse de que tienen una copia guardada del contenido actual de su c\u00f3digo, solo tienen que correr git add . y despu\u00e9s git commit en la terminal. Un \u00faltimo comando de git que pueden encontrar bastante util es git log . Pueden ejectuar este comando en la terminal y van a ver un historial o log de todos los commits que se han hecho (en el branch actual), incluyendo el tiempo y quien hizo el commit. Ejercicio 3: Alfabeto Binario Vamos a utilizar n\u00fameros de 4 bits. Si apilamos cinco n\u00fameros de 4 bits uno encima de otro en binario, podemos crear patrones e im\u00e1genes. Para ayudarlos a visualizar esto, pueden pensar que un bit en cero es blanco y un bit en uno es negro. Por ejemplo miren el siguiente patr\u00f3n de bits. Preguntas \u00bfCu\u00e1les son los cinco n\u00fameros en decimal (separados por una coma) que producen el patr\u00f3n de arriba? \u00bfCu\u00e1les son los cinco digitos en hexadecimal (separados por una coma) que producen el patr\u00f3n de arriba? \u00bfQu\u00e9 letra se dibuja con los siguientes n\u00fameros en decimal: 1,1,9,9,6? \u00bfQu\u00e9 letra se dibuja con el siguiente numero en hexadecimal: 0xF8F88? \u00bfCu\u00e1l es el numero en hexadecimal para dibujar la letra b (min\u00fascula)? \u00bfUtilizar\u00edas cinco d\u00edgitos hexadecimales para dibujar la letra N? Contesten Si o No En los archivos del laboratorio van a encontrar un archivo de texto ex3.txt con lo siguiente: 1 2 3 4 5 6 1: 2: 3: 4: 5: 6: En este archivo tienen que colocar todas sus respuestas de las preguntas de arriba siguiendo ese formato por ejemplo un archivo valido ser\u00eda: 1 2 3 4 5 6 1:1,2,3,4,5 2:0x1,0x2,0x3,0x4,0x5 3:A 4:A 5:0xcafee 6:Si/No Si ya contestaron todo y creen que est\u00e1 correcto pueden agregar los cambios, hacer commit y subirlo al repositorio remoto ejecutando los siguientes comandos en la terminal: 1 2 3 git add ex4.txt git commit -m \"ex. 3 complete\" git push -u origin main Ejercicio 4: 1,000 billetes de $1 Imaginen que tienen mil billetes de $1 y 10 sobres. Para este ejercicio tienen que encontrar una manera de poner una cantidad determinada de billetes de $1 en cada uno de los sobres de tal forma que, sin importar la cantidad de dinero que se les pida (entre $1 y $1000), simplemente entreguen una combinaci\u00f3n de los sobres y que siempre est\u00e9n seguros de que est\u00e1n dando la cantidad correcta. En los archivos del laboratorio hay un archivo de texto llamado ex4.txt en donde encontrar\u00e1n lo siguiente: 1 a,b,c,d,e,f,g,h,i,j Cada una de las letras representa un sobre, tienen que reemplazar cada letra por la cantidad de billetes de $1 que crean correcta, esa cantidad tiene que ser >= 0 (en decimal) y recuerda que la suma de la cantidad de cada uno de los sobres tiene que ser igual a 1000 . Si ya contestaron todo y creen que est\u00e1 correcto pueden agregar los cambios, hacer commit y subirlo al repositorio remoto ejecutando los siguientes comandos en la terminal: 1 2 3 git add ex4.txt git commit -m \"ex. 4 complete\" git push -u origin main Entrega y calificaci\u00f3n A partir del siguiente lab tendremos autograder y podran conocer su nota inmediatamente. Listo, terminaron su primer laboratorio. No olviden que tienen que subir SIEMPRE la URL del repositorio en la asignaci\u00f3n del GES. La URL se tiene que ver algo como lo siguiente: 1 https://www.github.com/cc3-an/2021-lab00-git-<USUARIO>","title":"00: Git"},{"location":"labs/lab00/#lab-0-git-y-representacion-de-numeros","text":"","title":"Lab 0 - Git y Representaci\u00f3n de N\u00fameros"},{"location":"labs/lab00/#objetivos","text":"Aprender git y crear cuenta de GitHub. Ganar m\u00e1s intuici\u00f3n para trabajar con n\u00fameros binarios.","title":"Objetivos"},{"location":"labs/lab00/#lecturas","text":"P&H: 2.4","title":"Lecturas"},{"location":"labs/lab00/#ejercicio-1-cuenta-de-github","text":"Por favor lean las siguientes instrucciones cuidadosamente antes de seguir con el laboratorio. La mayor parte de los problemas que tienen los estudiantes durante este laboratorio se pueden prevenir siguiendo atentamente los pasos que se indican. Para este curso necesitaremos que utilicen git , un sistema de control de versiones distribuido . Los sistemas de control de versiones son las mejores herramientas para compartir y almacenar c\u00f3digo a comparaci\u00f3n de mandar correos con archivos adjuntos, utilizar memorias flash, o incluso compartir documentos mediante DropBox o Google Docs. Vamos a estar usando GitHub para tener repositorios privados en donde van a almacenar su c\u00f3digo remotamente. Si la oraci\u00f3n anterior no les dijo nada, no se preocupen, vamos a guiarlos en el proceso m\u00e1s adelante. Pero primero, necesitan crear una cuenta de GitHub . \u00bfPor qu\u00e9 GitHub? GitHub ahora le permite a todas las cuentas gratuitas tener repositorios privados ilimitados con algunas limitaciones que no van a ser ning\u00fan problema para nosotros.","title":"Ejercicio 1: Cuenta de GitHub"},{"location":"labs/lab00/#github-onboarding","text":"Naveguen a la siguiente p\u00e1gina: github.com . Si no tienen una cuenta de GitHub todav\u00eda, creen una en el siguiente link .","title":"GitHub Onboarding"},{"location":"labs/lab00/#preparacion","text":"Visiten este link . Aqu\u00ed encontrar\u00e1n todos los archivos necesarios para completar este laboratorio. En esta p\u00e1gina, encontrar\u00e1n un bot\u00f3n que dice \"Accept this assignment\". Al presionar este bot\u00f3n, se crear\u00e1 autom\u00e1ticamente un repositorio en Github llamado https://www.github.com/cc3-an/2021-lab00-git-<USUARIO> . Noten que el \"due\u00f1o\" de este repositorio es un usuario llamado cc3-an , y el usuario de ustedes es \u00fanicamente el sufijo del nombre del repo. De esta forma, nos encargamos de tener acceso siempre a su c\u00f3digo, en caso existan copias o cualquier otro tipo de trampa. Sepan de una vez que, si encontramos plagio en sus laboratorios, su nota ser\u00e1 AUTOM\u00c1TICAMENTE 0, sin posibilidad de cambiarla. De repetirse nuevamente este acontecimiento, el staff del curso organizar\u00e1 una reuni\u00f3n con ustedes y sus directores de carrera para contarles lo ocurrido y sancionarlos conforme al reglamento de la universidad. Despu\u00e9s de realizar esto, en la m\u00e1quina virtual (o sus propias computadoras) abran una terminal en el directorio que prefieran, y ejecuten el siguiente comando: 1 git clone https://github.com/cc3-an/2021-lab00-git-<SU USUARIO DE GITHUB> esto descargar\u00e1 en el directorio que escogieron todos los archivos base para este laboratorio.","title":"Preparaci\u00f3n"},{"location":"labs/lab00/#configurando-git","text":"Ahora que ya hemos creado nuestro repositorio, vamos a configurar git para que sepa qui\u00e9nes son. Abran una terminal Ctrl + Alt + T y ejecuten los siguientes comandos listados abajo, reemplazando NOMBRE con su nombre y apellido (entre comillas) y CORREO con la direcci\u00f3n de correo que utilizar\u00f3n para registrarse en GitHub. 1 git config --global user.name \"NOMBRE\" 1 git config --global user.email \"CORREO\"","title":"Configurando git"},{"location":"labs/lab00/#ejercicio-2-git-y-remotes","text":"Primero, algunas definiciones r\u00e1pidas: Un remote es la p\u00e1gina web host o servidor que va a almacenar su c\u00f3digo remotamente en vez de tener \u00fanicamente el c\u00f3digo de forma local en su propia computadora. Pueden pensar en esto de igual manera a como se almacena un archivo en DropBox o Google Drive pero con el poder que nos da git. Un branch es una secuencia (por aparte) de diferentes cambios a su c\u00f3digo. Pueden pensar en los branches como diferentes versiones de su c\u00f3digo, que en alg\u00fan punto fueron lo mismo. La siguiente figura muestra a que nos referimos como branches. A lo largo de este curso, estar\u00e1n trabajando en dos diferentes \" computadoras \" que generalmente tendran diferentes versiones de su c\u00f3digo en alg\u00fan tiempo. Estas dos son: su computadora personal y su remote de GitHub (sus repositorios privados de GitHub). Es esencial que entiendan la diferencia entre estas dos y como pueden compartir c\u00f3digo entre ellas. Su computadora personal es la que les servir\u00e1 para hacer todo el trabajo (laboratorios y proyectos) que necesiten hacer durante el curso, nada nuevo aqu\u00ed. Su cuenta de GitHub y los remotes les servir\u00e1n para muchos prop\u00f3sitos, pero la principal raz\u00f3n es para tener un backup o copia de respaldo, de tal manera que si algo malo le sucede a sus computadoras (esperamos no ), puedan recuperar su c\u00f3digo en vez de empezar de cero nuevamente. Conceptualmente, pueden pensar en los remotes de GitHub como otra computadora que \u00fanicamente almacena su c\u00f3digo y nada m\u00e1s. Siempre deben subir sus cambios a GitHub haciendo push al remote (es decir actualizando los archivos en GitHub) y tambi\u00e9n pueden descargar los cambios de GitHub haciendo pull (actualizando los archivos en su computadora personal).","title":"Ejercicio 2: git y Remotes"},{"location":"labs/lab00/#haciendo-push-hacia-github","text":"Vamos a crear un archivo llamado hello.sh en la carpeta del laboratorio ejecutando el siguiente commando en la terminal: 1 echo 'echo \"Hola Mundo\"' > hello.sh Luego pueden correr el archivo en la terminal con bash hello.sh . En la terminal se imprimir\u00e1 Hola Mundo . Ahora utilicemos git para ver los archivos que todav\u00eda no han sido rastreados utilizando status : 1 git status Lo que producir\u00e1 lo siguiente: 1 2 3 4 5 6 7 8 9 10 On branch main No commits yet Untracked files: ( use \"git add <file>...\" to include in what will be committed ) hello.sh nothing added to commit but untracked files present ( use \"git add\" to track ) Esto es porque hemos creado un archivo nuevo llamado hello.sh y no lo hemos agregado. Podemos agregarlo y hacer commit: 1 2 3 4 git add hello.sh # agrega el archivo hello.sh para hacer commit git commit -m \"Mensaje del Commit\" # ingresa cualquier mensaje que quieras git branch # deberias de ver que solo existe el branch main y que estas en ella (*) git push -u origin main # Esto hace push de tu codigo hacia GitHub (lo puedes ver en GitHub ahora) El control de versiones git esta construido alrededor de commits , o checkpoints en el desarrollo de diferentes versiones/etapas de su c\u00f3digo. Para explicar los pasos de arriba un poco m\u00e1s: git add [archivo] le dir\u00e1 a git que han hecho cambios a ese archivo y que quieren que esos cambios se guarden en el siguiente commit (staging). git commit -m \"mensaje\" oficialmente guarda esos cambios que acaban de agregar, y crea un snapshot del contenido actual de todos los archivos en el repositorio. Ahora siempre van a tener la opci\u00f3n de revertir su c\u00f3digo hacia este commit. git push -u origin main manda todo el contenido del repositorio que est\u00e1 en el branch \"main\" al repositorio remoto \"origin\" (recuerden que agregamos el repositorio de GitHub \"lab0_git\" como remote y lo llamamos \"origin\"). Cuando estamos trabajando con git, si alguna vez no est\u00e1n seguros de algo, pero quieren asegurarse de que tienen una copia guardada del contenido actual de su c\u00f3digo, solo tienen que correr git add . y despu\u00e9s git commit en la terminal. Un \u00faltimo comando de git que pueden encontrar bastante util es git log . Pueden ejectuar este comando en la terminal y van a ver un historial o log de todos los commits que se han hecho (en el branch actual), incluyendo el tiempo y quien hizo el commit.","title":"Haciendo push hacia GitHub"},{"location":"labs/lab00/#ejercicio-3-alfabeto-binario","text":"Vamos a utilizar n\u00fameros de 4 bits. Si apilamos cinco n\u00fameros de 4 bits uno encima de otro en binario, podemos crear patrones e im\u00e1genes. Para ayudarlos a visualizar esto, pueden pensar que un bit en cero es blanco y un bit en uno es negro. Por ejemplo miren el siguiente patr\u00f3n de bits.","title":"Ejercicio 3: Alfabeto Binario"},{"location":"labs/lab00/#preguntas","text":"\u00bfCu\u00e1les son los cinco n\u00fameros en decimal (separados por una coma) que producen el patr\u00f3n de arriba? \u00bfCu\u00e1les son los cinco digitos en hexadecimal (separados por una coma) que producen el patr\u00f3n de arriba? \u00bfQu\u00e9 letra se dibuja con los siguientes n\u00fameros en decimal: 1,1,9,9,6? \u00bfQu\u00e9 letra se dibuja con el siguiente numero en hexadecimal: 0xF8F88? \u00bfCu\u00e1l es el numero en hexadecimal para dibujar la letra b (min\u00fascula)? \u00bfUtilizar\u00edas cinco d\u00edgitos hexadecimales para dibujar la letra N? Contesten Si o No En los archivos del laboratorio van a encontrar un archivo de texto ex3.txt con lo siguiente: 1 2 3 4 5 6 1: 2: 3: 4: 5: 6: En este archivo tienen que colocar todas sus respuestas de las preguntas de arriba siguiendo ese formato por ejemplo un archivo valido ser\u00eda: 1 2 3 4 5 6 1:1,2,3,4,5 2:0x1,0x2,0x3,0x4,0x5 3:A 4:A 5:0xcafee 6:Si/No Si ya contestaron todo y creen que est\u00e1 correcto pueden agregar los cambios, hacer commit y subirlo al repositorio remoto ejecutando los siguientes comandos en la terminal: 1 2 3 git add ex4.txt git commit -m \"ex. 3 complete\" git push -u origin main","title":"Preguntas"},{"location":"labs/lab00/#ejercicio-4-1000-billetes-de-1","text":"Imaginen que tienen mil billetes de $1 y 10 sobres. Para este ejercicio tienen que encontrar una manera de poner una cantidad determinada de billetes de $1 en cada uno de los sobres de tal forma que, sin importar la cantidad de dinero que se les pida (entre $1 y $1000), simplemente entreguen una combinaci\u00f3n de los sobres y que siempre est\u00e9n seguros de que est\u00e1n dando la cantidad correcta. En los archivos del laboratorio hay un archivo de texto llamado ex4.txt en donde encontrar\u00e1n lo siguiente: 1 a,b,c,d,e,f,g,h,i,j Cada una de las letras representa un sobre, tienen que reemplazar cada letra por la cantidad de billetes de $1 que crean correcta, esa cantidad tiene que ser >= 0 (en decimal) y recuerda que la suma de la cantidad de cada uno de los sobres tiene que ser igual a 1000 . Si ya contestaron todo y creen que est\u00e1 correcto pueden agregar los cambios, hacer commit y subirlo al repositorio remoto ejecutando los siguientes comandos en la terminal: 1 2 3 git add ex4.txt git commit -m \"ex. 4 complete\" git push -u origin main","title":"Ejercicio 4: 1,000 billetes de $1"},{"location":"labs/lab00/#entrega-y-calificacion","text":"A partir del siguiente lab tendremos autograder y podran conocer su nota inmediatamente. Listo, terminaron su primer laboratorio. No olviden que tienen que subir SIEMPRE la URL del repositorio en la asignaci\u00f3n del GES. La URL se tiene que ver algo como lo siguiente: 1 https://www.github.com/cc3-an/2021-lab00-git-<USUARIO>","title":"Entrega y calificaci\u00f3n"},{"location":"labs/lab01/","text":"Lab 1 - Punteros en C y GDB Objetivos Aprender c\u00f3mo compilar y ejecutar un programa en C. Examinar diferentes tipos de control de flujo en C. Introducirlos al debugger (depurador) de C Conseguir experiencia pr\u00e1ctica utilizando GBD para depurar programas en C. Ganar m\u00e1s confianza al trabajar con punteros. Preparaci\u00f3n Visiten este link . Aqu\u00ed encontrar\u00e1n todos los archivos necesarios para completar este lab. En esta p\u00e1gina, encontrar\u00e1n un bot\u00f3n que dice \"Accept assignment\". Al presionar este bot\u00f3n, se crear\u00e1 autom\u00e1ticamente un repositorio en Github llamado www.github.com/cc3-an/lab01-2021-USUARIO . Noten que el \"due\u00f1o\" de este repositorio es un usuario llamado cc3-an , y el usuario de ustedes es \u00fanicamente el sufijo del nombre del repo. De esta forma, nos encargamos de tener acceso siempre a su c\u00f3digo, en caso existan copias o cualquier otro tipo de trampa. Sepan de una vez que, si encontramos plagio o cualquier otro tipo de trampa en sus laboratorios, su nota ser\u00e1 AUTOM\u00c1TICAMENTE 0, sin posibilidad de cambiarla. De repetirse nuevamente este acontecimiento, el staff del curso organizar\u00e1 una reuni\u00f3n con ustedes y sus directores de carrera para contarles lo ocurrido y sancionarlos conforme al reglamento de la universidad. Despu\u00e9s de realizar esto, en la m\u00e1quina virtual (o sus propias computadoras) abran una terminal en el directorio que prefieran, y ejecuten el siguiente comando: 1 git clone https://github.com/cc3-an/lab1-2021-<SU USUARIO DE GITHUB> Esto descargar\u00e1 en el directorio que escogieron todos los archivos base para este laboratorio. Para futuro, un clone solo lo hacemos la primera vez que vamos a bajar el codigo de un repositorio a nuestra maquina. Nunca bajen el zip que Github les ofrece, por favor, eso solo nos va a causar problemas. Compilando y ejecutando un programa de C En este laboratorio, estaremos usando el programa gcc para compilar programas en c. La manera m\u00e1s sencilla de ejecutar gcc es la siguiente: 1 gcc program.c Esto compila el archivo program.c y crea un archivo ejecutable llamado a.out . Si tienen experiencia en Java, pueden m\u00e1s o menos considerar a gcc como el equivalente en C de javac . Este archivo se puede ejecutar con el siguiente comando: 1 ./a.out El archivo ejecutable es a.out , as\u00ed que, \u00bfqu\u00e9 rayos es eso de punto y diagonal? La respuesta: cuando quieren ejecutar un ejecutable, es necesario preponer una ruta de archivo para distinguirlo de un comando como python (no se utiliza ./python ). El punto se refiere al \"directorio actual\". De paso, dos puntos (..) se referir\u00edan al directorio que est\u00e1 un nivel arriba. gcc tiene varias opciones (o argumentos) de l\u00ednea de comandos, los cuales les recomendamos explorar. En este laboratorio, vamos a estar usando solamente -o, que se usa para especificar el nombre del ejecutable que gcc genera. Usando -o, se utilizar\u00edan estos comandos para compilar program.c en un archivo llamado program , y ejecutarlo. Eso nos sirve si no queremos que todos nuestros archivos ejecutables se llamen a.out . 1 2 gcc -o program program.c ./program Ejercicio 1: Programa simple de C En este ejercicio, veremos un ejemplo de definiciones macro de preprocesador. Las macros pueden ser un tema complicado, pero en general, la forma en que funcionan es que, antes de que un archivo en C es compilado, las constantes macro son reemplazadas exactamente por el valor al que se refieren. En este ejercicio, estaremos usando macros exclusivamente como constantes globales. Aqu\u00ed definimos CONSTANT_NAME como un literal_value (una literal entera). Noten que solo hay 1 espacio separando el nombre del valor. 1 #define CONSTANT_NAME LITERAL_VALUE Ahora, vean el c\u00f3digo en eccentric.c (en el repo). Noten los cuatro diferentes ejemplos de control b\u00e1sico de flujo. (\u00bfCu\u00e1les son?) Compilen y ejecuten el programa para ver lo que hace. Jueguen con las constantes de las cuatro macros: v0 a v3 . Vean c\u00f3mo cambiar cada uno de estos cambia el output del programa. Su tarea: Modificando s\u00f3lo estos cuatro valores, hagan que el programa produzca el siguiente mensaje: 1 2 3 4 5 6 7 8 $ gcc -o eccentric eccentric.c $ ./eccentric Berkeley eccentrics: ==================== Happy Happy Happy Yoshua Go BEARS! Hay m\u00faltiples combinaciones de valores en las macros que consiguen este resultado, El reto para ustedes en este ejercicio es: Consideren el m\u00ednimo n\u00famero de distintos valores que las constantes v0 a v3 puedan tener que a\u00fan den el mismo resultado correcto. Como ejemplo, el m\u00e1ximo te\u00f3rico es cuatro (cuando todos son diferentes uno de otro). Cuando ya hayan logrado esto, pueden actualizar el archivo en su repositorio en Github, de esta manera: 1 2 3 $ git add eccentric.c $ git commit -m \"Ejercicio 1 terminado\" $ git push -u origin main Ejercicio 2: Debugger (depurador) \u00bfQu\u00e9 es un debugger ? Este p\u00e1rrafo es para los estudiantes que no est\u00e1n familiarizados con los debuggers . Un debugger , como sugiere el nombre, es un programa espec\u00edficamente dise\u00f1ado para ayudarlos a encontrar bugs , o errores l\u00f3gicos, u otros errores en el c\u00f3digo (nota: si quieren saber por qu\u00e9 se les llama bugs a los errores, vean aqu\u00ed ). Distintos debuggers tienen distintas caracter\u00edsticas, pero es normal que todos los debuggers sean capaces de hacer las siguientes cosas: Poner un breakpoint en el programa. Un Breakpoint es una l\u00ednea espec\u00edfica en su c\u00f3digo en donde quisieran que se detenga la ejecuci\u00f3n del programa, para que puedan ver lo que est\u00e1 pasando alrededor. Ejecuci\u00f3n por Steps (l\u00ednea a l\u00ednea) por el programa. El c\u00f3digo siempre se ejecuta l\u00ednea a l\u00ednea, pero pasa muy r\u00e1pido como para que sepamos qu\u00e9 l\u00ednea produce alg\u00fan error. Ser capaces de ejecutar l\u00ednea a l\u00ednea el programa les permite observar exactamente qu\u00e9 esta causando un bug en el programa. Para este ejercicio, necesitar\u00e1n la GDB reference card . GDB quiere decir \"GNU De-Bugger\". Compilen hello.c con la bandera \"-g\": 1 gcc -g -o hello hello.c Esto har\u00e1 que gcc guarde informaci\u00f3n en el archivo ejecutable para que gdb lo interprete. Ahora ejecuten el debugger, (c)gdb: 1 cgdb hello Vean lo que hace este comando. Est\u00e1n ejecutando el programa cgdb en el ejecutable hello generado por gcc . No intenten ejecutar cgdb en el archivo fuente en hello.c ! Eso no va a funcionar. Si cgdb no funciona, gdb se puede usar para completar los ejercicios (utilicen gdb hello ). Su tarea: ejecuten el programa varias veces haciendo esto: Poniendo un breakpoint en el main. Usando el comando run de gdb. Utilizando el comando single-step de gdb. Escriban help adentro de gdb para averiguar c\u00f3mo hacer estas cosas, o usen la reference card. Si encuentran un mensaje de error que dice: printf.c: No such file or directory . Probablemente entraron a una funci\u00f3n printf . Si siguen ejecutando paso a paso, pareciera que nunca avanzaran en el c\u00f3digo. CGDB est\u00e1 dando el error porque no tienen el archivo en el que se define la funci\u00f3n printf . Esto es algo molesto, y para librarse de esto, usen el comando finish para ejecutar el programa hasta que termine la funci\u00f3n printf. Y la pr\u00f3xima vez , utilicen el comando next para saltar sobre la linea que usa printf . Nota: CGDB vs GDB . En este ejercicio, usamos cgdb para depurar nuestros programas. cgdb es id\u00e9ntico a gdb, excepto que tiene unas caracter\u00edsticas extra que hacen m\u00e1s c\u00f3modo el trabajo. Todos los comandos de la hoja de referencia funcionan tambi\u00e9n en gdb. En cgdb, pueden presionar ESC para ir a la ventana del c\u00f3digo (arriba), y usar i para regresar a la ventana de comandos (abajo), similar a vim . La ventana de comandos es donde se introducen los comandos de gdb. Para este ejercicio, encontrar\u00e1n un archivo de texto llamado ex2.txt, con el siguiente formato: 1 2 3 4 5 6 7 8 9 1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : Aqu\u00ed tendr\u00e1n que responder las siguientes preguntas de opci\u00f3n m\u00faltiple (no tengan miedo de probar las opciones en CGDB antes de responder, \u00a1lo recomendamos!) con el siguiente formato (tienen que cambiar la letra en el ejemplo por la letra de la respuesta que ustedes consideren correcta): 1 2 3 4 5 6 7 8 9 1 :e 2 :f 3 :g 4 :h 5 :i 6 :j 7 :k 8 :l 9 :m Preguntas 1. \u00bfC\u00f3mo se le dan argumentos desde la l\u00ednea de comandos a un programa al utilizar gdb? a. args arglist b. run arglist c. gdb args d. Ninguna de las anteriores 2. \u00bfC\u00f3mo se a\u00f1ade un breakpoint que s\u00f3lo ocurre cuando se cumplen ciertas condiciones (por ejemplo, ciertas variables alcanzan cierto valor)? a. expr cond b. cond break expr c. break ... if expr d. Ninguna de las anteriores 3. \u00bfCon qu\u00e9 comando se ejecuta la siguiente l\u00ednea del c\u00f3digo en C despu\u00e9s de parar en un breakpoint? a. run b. s c. c d. n 4. Si la siguiente l\u00ednea de c\u00f3digo es una llamada a funci\u00f3n, \u00bfse ejecutar\u00eda toda la funci\u00f3n si se utiliza el comando de la pregunta #3? (si no, es momento de cambiarla!). \u00bfC\u00f3mo se le indica a gdb, que quieren debuggear el c\u00f3digo adentro de la funci\u00f3n ? (Si tuvieron que cambiar la respuesta #3, esa respuesta muy probablemente aplica aqu\u00ed) a. run b. s c. c d. n 5. \u00bfC\u00f3mo se reanuda la ejecuci\u00f3n del programa despu\u00e9s de parar en un breakpoint? a. run b. s c. c d. n 6. \u00bfC\u00f3mo podemos ver el valor de una variable (o expresi\u00f3n) en gdb? a. display expr b. signal expr c. print expr d. next expr 7. \u00bfQu\u00e9 comando de gdb se usa para desplegar el valor de una variable despu\u00e9s de cada paso ? a. display expr b. signal expr c. print expr d. next expr 8. \u00bfC\u00f3mo se imprime una lista de todas las variables y su valor en la funci\u00f3n actual? a. display all b. display c. print all d. print 9. \u00bfC\u00f3mo salimos de gdb? a. end b. quit c. exit d. finish Despu\u00e9s de responder estas preguntas, no olviden hacer el commit y push de este archivo hacia Github: 1 2 3 $ git add ex2.txt $ git commit -m \"Ejercicio 2 terminado\" $ git push -u origin main Ejercicio 3: Depurando un problema con fallas usando GDB Ahora, usar\u00e1n su nuevo conocimiento para depurar un peque\u00f1o programa. Vean el programa ll_equal.c . Compilen y ejecuten el programa, y analicen un poco lo que hace. As\u00ed como est\u00e1, producir\u00e1 un resultado como el siguiente: 1 2 3 4 $ gcc -g -o ll_equal ll_equal.c $ ./ll_equal equal test 1 result = 1 Segmentation fault Averig\u00fcen qu\u00e9 produce el segmentation fault (falla de segmentaci\u00f3n) . Ejecuten gdb en el programa, siguiendo las instrucciones aprendidas en los ejercicios anteriores. Les recomendamos a\u00f1adir un breakpoint en la funci\u00f3n ll_equal() . Cuando el debugger pare en el breakpoint, ejecuten paso a paso el programa, para que puedan descifrar qu\u00e9 es lo que provoca el error. Pista: Analicen el valor de los punteros a y b en la funci\u00f3n (\u00a1despli\u00e9guenlos!). \u00bfEst\u00e1n siempre apuntando a la direcci\u00f3n correcta? Pista 2: Vean el c\u00f3digo fuente en main para ver la estructura de los nodos y ver exactamente qu\u00e9 est\u00e1 pasando como argumento a ll_equal . Despu\u00e9s de corregir el problema, compilen nuevamente y ejecuten el c\u00f3digo. \u00bfNotan la diferencia? Al finalizar, no olviden subir el archivo modificado a su repositorio remoto: 1 2 3 $ git add ll_equal.c $ git commit -m \"Ejercicio 2 terminado\" $ git push -u origin main Ejercicio 4: \"Debuggeando\" un programa en C que requiere interacci\u00f3n del usuario Veamos qu\u00e9 pasa cuando, a un programa que requiere interacci\u00f3n del usuario, lo ejecutamos con gdb. Primero, ejecuten el programa en interactive_hello.c para hablar con un programa muy amigable :). 1 2 $ gcc -g -o int_hello interactive_hello.c $ ./int_hello Ahora, traten de depurarlo (aunque no haya ning\u00fan problema realmente): 1 $ cgdb int_hello \u00bfQu\u00e9 pasa cuando intentar ejecutar el programa hasta el final? Vamos a aprender acerca de una herramienta que nos ayudar\u00e1 a evitar este problema. El prop\u00f3sito de este ejercicio es que no tengan miedo de usar un debugger incluso cuando el programa requiera de interacci\u00f3n con el usuario. Resulta que es posible enviar texto a stdin , el flujo de datos que es le\u00eddo por la funci\u00f3n fgets en este programa, con unos caracteres especiales desde la l\u00ednea de comandos. Echen un vistazo a la \"redirecci\u00f3n\" en esta p\u00e1gina , y vean si pueden descifrar c\u00f3mo enviar texto al programa sin escribirlo textualmente mientras el programa est\u00e1 en ejecuci\u00f3n (lo cual, como ya saben, no funciona bien en CGDB). Pueden ver esta discusi\u00f3n de stackoverflow para m\u00e1s inspiraci\u00f3n. (Pista 1: \u00a1Si est\u00e1n creando un archivo de texto que contiene su input, van bien!) (pista 2: Recuerden que es posible ejecutar programas con argumentos (incluyendo s\u00edmbolos de redirecci\u00f3n) desde CGDB! Esperamos que hayan comprendido c\u00f3mo utilizar redirecci\u00f3n y c\u00f3mo es que esto les ayuda a evitar varios problemas al usar CGDB. \u00a1Nunca tengan miedo de usar un debugger ! Tal vez no es muy agradable visualmente, pero siempre estar\u00e1 para ayudarlos. Este ejercicio no vale puntos :-) pero es importante conocer sobre estas cosas para que puedan utilizarlo en el futuro (los siguientes laboratorios y proyectos podr\u00edan necesitar de este conocimiento) Ejercicio 5: Punteros y estructuras en C En ll cycle.c, completen la funci\u00f3n ll_has_cycle(), de modo que implemente el siguiente algoritmo para comprobar si una _linked list simple tiene un ciclo: Comiencen con dos punteros apuntando al principio de la lista. Llamaremos al primero tortoise (tortuga) y al segundo hare (liebre). Avancen el puntero hare dos nodos hacia adelante. Si no se puede debido a punteros null , hemos llegado al final de la lista. Por lo tanto, la lista no tiene un ciclo. Ahora, avancen tortoise un nodo. (Revisar si llega a ser un puntero nulo es innecesario. \u00bfPor qu\u00e9?) Si la tortuga y la liebre apuntan al mismo nodo, la lista es c\u00edclica. Si no, regresen al paso 2. Despu\u00e9s de implementar correctamente la funci\u00f3n ll_has_cycle() , el programa que se obtiene despu\u00e9s de compilar ll_cycle.c mostrar\u00e1 si el resultado de su funci\u00f3n est\u00e1 correcto, conforme a lo que esperaba como salida. Pista: Hay dos formas comunes en que los estudiantes resuelven esta funci\u00f3n, y la diferencia principal est\u00e1 en la forma en que deciden codificar el criterio de c\u00f3mo finalizar. Si lo hacen de una forma, tendr\u00edan que tomar en cuenta un caso especial en el principio. Si lo hacen de otra forma, tendr\u00edan que tener unas pruebas extra de NULL, lo cual esta bien tambi\u00e9n. Les decimos esto para que no se preocupen de la \"limpieza\" de su c\u00f3digo, si no les ayuda, simplemente ignoren esta pista. El punto de este ejercicio es asegurarse de que entiendan como usar punteros. Aqu\u00ed hay un Art\u00edculo del algoritmo y por qu\u00e9 funciona. No se preocupen de entender completamente todo (no hay examen de esto). A prop\u00f3sito, los punteros se llaman tortoise y hare porque el puntero \"tortoise (tortuga)\" se incrementa lentamente (como una tortuga, que se mueve muy lento) y el puntero \"hare (liebre)\" se incrementa r\u00e1pidamente (m\u00e1s r\u00e1pido que una tortuga, como una liebre, o conejo, que se mueve muy r\u00e1pido). Al finalizar, compilen y ejecuten el archivo, y verifiquen que el resultado de su c\u00f3digo, el cual deber\u00eda ser m\u00e1s o menos igual a este: 1 2 3 4 5 6 7 8 $ gcc -g -o ll_cycle ll_cycle.c $ ./ll_cycle Checking first list for cycles. There should be none, ll_has_cycle says it has no cycle Checking second list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking third list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking fourth list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking fifth list for cycles. There should be none, ll_has_cycle says it has no cycle Checking length-zero list for cycles. There should be none, ll_has_cycle says it has no cycle Si su c\u00f3digo presenta errores, entonces ya son capaces de utilizar CGDB para poder encontrarlos y corregirlos. Finalmente, pueden subir el archivo a github: 1 2 3 $ git add ll_cycle.c $ git commit -m \"LAB01 terminado\" $ git push -u origin main Para finalizar, la f\u00e1bula de la tortuga y la liebre es relevante siempre, especialmente en este curso. Escribir sus programas en C a paso lento pero seguro (ayud\u00e1ndose de programas como CGDB) es lo que les har\u00e1 ganar la carrera. Entrega de laboratorio A partir de este laboratorio contaremos con autograders, por lo que podr\u00e1 conocer su nota de inmediato. Para poder utilizarlo debemos realizar una pequena instalaci\u00f3n (todos, incluyendo a quienes bajaron nuestra m\u00e1quina virtual, los autograders est\u00e1n reci\u00e9n salidos del horno). Para instalar necesitamos tener Python 3.6 o superior, nuestra m\u00e1quina virtual ya lo cumple. Comenzamos con... 1 pip3 install autograders-cli Esto instala el modulo a traves del cual entregar\u00e1 su asignaci\u00f3n. Luego tenemos que registrarnos. Por favor sea MUY CUIDADOSO al ingresar sus datos. Como es usual en Linux no se vera su contrasena mientras la escribe, de momento NO EXISTE RECUPERACION DE CONTRASENA por si se equivoca o se le olvida. SEA MUY CUIDADOSO . 1 autograder --register Tras llenar su nombre completo, correo y crear su contrase\u00f1a se le enviar\u00e1 un correo. Haga click en el link que va en el correo (es posible que al hacer click se quede \"trabado\" en redirecting/redirigiendo, esto es normal, no se preocupe). Luego de hacer click en ese link, esta listo para entregar. Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json ; si aparecio, est\u00e1 en el lugar correcto. Ahora puede entregar su laboratorio con... 1 autograder --upload Espera un minuto aproximadamente y luego puede ver sus resultados con... 1 autograder --stats Vera desplegado sus resultados de esta manera (excepto que usted tendra 100 en lugar de 0 :P). Si dice Queued: True significa que el autograder esta un poquito ocupado y no le ha calificado, revise de nuevo en unos cinco minutos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ___ __ __ / _ | __ __/ /____ ___ ________ ____/ /__ _______ / __ / // / __/ _ \\/ _ ` / __/ _ ` / _ / -_ ) __ ( _- /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ /___/ Command Line Interface Autograders.org Get Task Stats - Queued: False - Grade: 0 .00/100 - Created At: 2021 -01-29T12:57:05.454Z - Updated At: 2021 -01-29T12:57:12.131Z Details: \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555 \u2502 Name \u2502 Grade \u2502 Message \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 1 . Eccentric \u2502 0 \u2502 incomplete: some answers are wrong... \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 2 . CGDB \u2502 0 \u2502 incomplete: q1,q2,q3,q4,q5,q6,q7,q8,q9 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 . ll_equal \u2502 0 \u2502 failed: runtime error \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 4 . ll_cycle \u2502 0 \u2502 failed: Failed some tests... \u2502 \u2558\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255b Felicidades! Termino su lab 1. Envie el link de su repo en el GES (el GES le permite enviar links, no pegue su link en un TXT u otro documento, es inc\u00f3modo).","title":"01: C y GDB"},{"location":"labs/lab01/#lab-1-punteros-en-c-y-gdb","text":"","title":"Lab 1 - Punteros en C y GDB"},{"location":"labs/lab01/#objetivos","text":"Aprender c\u00f3mo compilar y ejecutar un programa en C. Examinar diferentes tipos de control de flujo en C. Introducirlos al debugger (depurador) de C Conseguir experiencia pr\u00e1ctica utilizando GBD para depurar programas en C. Ganar m\u00e1s confianza al trabajar con punteros.","title":"Objetivos"},{"location":"labs/lab01/#preparacion","text":"Visiten este link . Aqu\u00ed encontrar\u00e1n todos los archivos necesarios para completar este lab. En esta p\u00e1gina, encontrar\u00e1n un bot\u00f3n que dice \"Accept assignment\". Al presionar este bot\u00f3n, se crear\u00e1 autom\u00e1ticamente un repositorio en Github llamado www.github.com/cc3-an/lab01-2021-USUARIO . Noten que el \"due\u00f1o\" de este repositorio es un usuario llamado cc3-an , y el usuario de ustedes es \u00fanicamente el sufijo del nombre del repo. De esta forma, nos encargamos de tener acceso siempre a su c\u00f3digo, en caso existan copias o cualquier otro tipo de trampa. Sepan de una vez que, si encontramos plagio o cualquier otro tipo de trampa en sus laboratorios, su nota ser\u00e1 AUTOM\u00c1TICAMENTE 0, sin posibilidad de cambiarla. De repetirse nuevamente este acontecimiento, el staff del curso organizar\u00e1 una reuni\u00f3n con ustedes y sus directores de carrera para contarles lo ocurrido y sancionarlos conforme al reglamento de la universidad. Despu\u00e9s de realizar esto, en la m\u00e1quina virtual (o sus propias computadoras) abran una terminal en el directorio que prefieran, y ejecuten el siguiente comando: 1 git clone https://github.com/cc3-an/lab1-2021-<SU USUARIO DE GITHUB> Esto descargar\u00e1 en el directorio que escogieron todos los archivos base para este laboratorio. Para futuro, un clone solo lo hacemos la primera vez que vamos a bajar el codigo de un repositorio a nuestra maquina. Nunca bajen el zip que Github les ofrece, por favor, eso solo nos va a causar problemas.","title":"Preparaci\u00f3n"},{"location":"labs/lab01/#compilando-y-ejecutando-un-programa-de-c","text":"En este laboratorio, estaremos usando el programa gcc para compilar programas en c. La manera m\u00e1s sencilla de ejecutar gcc es la siguiente: 1 gcc program.c Esto compila el archivo program.c y crea un archivo ejecutable llamado a.out . Si tienen experiencia en Java, pueden m\u00e1s o menos considerar a gcc como el equivalente en C de javac . Este archivo se puede ejecutar con el siguiente comando: 1 ./a.out El archivo ejecutable es a.out , as\u00ed que, \u00bfqu\u00e9 rayos es eso de punto y diagonal? La respuesta: cuando quieren ejecutar un ejecutable, es necesario preponer una ruta de archivo para distinguirlo de un comando como python (no se utiliza ./python ). El punto se refiere al \"directorio actual\". De paso, dos puntos (..) se referir\u00edan al directorio que est\u00e1 un nivel arriba. gcc tiene varias opciones (o argumentos) de l\u00ednea de comandos, los cuales les recomendamos explorar. En este laboratorio, vamos a estar usando solamente -o, que se usa para especificar el nombre del ejecutable que gcc genera. Usando -o, se utilizar\u00edan estos comandos para compilar program.c en un archivo llamado program , y ejecutarlo. Eso nos sirve si no queremos que todos nuestros archivos ejecutables se llamen a.out . 1 2 gcc -o program program.c ./program","title":"Compilando y ejecutando un programa de C"},{"location":"labs/lab01/#ejercicio-1-programa-simple-de-c","text":"En este ejercicio, veremos un ejemplo de definiciones macro de preprocesador. Las macros pueden ser un tema complicado, pero en general, la forma en que funcionan es que, antes de que un archivo en C es compilado, las constantes macro son reemplazadas exactamente por el valor al que se refieren. En este ejercicio, estaremos usando macros exclusivamente como constantes globales. Aqu\u00ed definimos CONSTANT_NAME como un literal_value (una literal entera). Noten que solo hay 1 espacio separando el nombre del valor. 1 #define CONSTANT_NAME LITERAL_VALUE Ahora, vean el c\u00f3digo en eccentric.c (en el repo). Noten los cuatro diferentes ejemplos de control b\u00e1sico de flujo. (\u00bfCu\u00e1les son?) Compilen y ejecuten el programa para ver lo que hace. Jueguen con las constantes de las cuatro macros: v0 a v3 . Vean c\u00f3mo cambiar cada uno de estos cambia el output del programa. Su tarea: Modificando s\u00f3lo estos cuatro valores, hagan que el programa produzca el siguiente mensaje: 1 2 3 4 5 6 7 8 $ gcc -o eccentric eccentric.c $ ./eccentric Berkeley eccentrics: ==================== Happy Happy Happy Yoshua Go BEARS! Hay m\u00faltiples combinaciones de valores en las macros que consiguen este resultado, El reto para ustedes en este ejercicio es: Consideren el m\u00ednimo n\u00famero de distintos valores que las constantes v0 a v3 puedan tener que a\u00fan den el mismo resultado correcto. Como ejemplo, el m\u00e1ximo te\u00f3rico es cuatro (cuando todos son diferentes uno de otro). Cuando ya hayan logrado esto, pueden actualizar el archivo en su repositorio en Github, de esta manera: 1 2 3 $ git add eccentric.c $ git commit -m \"Ejercicio 1 terminado\" $ git push -u origin main","title":"Ejercicio 1: Programa simple de C"},{"location":"labs/lab01/#ejercicio-2-debugger-depurador","text":"","title":"Ejercicio 2: Debugger (depurador)"},{"location":"labs/lab01/#que-es-un-debugger","text":"Este p\u00e1rrafo es para los estudiantes que no est\u00e1n familiarizados con los debuggers . Un debugger , como sugiere el nombre, es un programa espec\u00edficamente dise\u00f1ado para ayudarlos a encontrar bugs , o errores l\u00f3gicos, u otros errores en el c\u00f3digo (nota: si quieren saber por qu\u00e9 se les llama bugs a los errores, vean aqu\u00ed ). Distintos debuggers tienen distintas caracter\u00edsticas, pero es normal que todos los debuggers sean capaces de hacer las siguientes cosas: Poner un breakpoint en el programa. Un Breakpoint es una l\u00ednea espec\u00edfica en su c\u00f3digo en donde quisieran que se detenga la ejecuci\u00f3n del programa, para que puedan ver lo que est\u00e1 pasando alrededor. Ejecuci\u00f3n por Steps (l\u00ednea a l\u00ednea) por el programa. El c\u00f3digo siempre se ejecuta l\u00ednea a l\u00ednea, pero pasa muy r\u00e1pido como para que sepamos qu\u00e9 l\u00ednea produce alg\u00fan error. Ser capaces de ejecutar l\u00ednea a l\u00ednea el programa les permite observar exactamente qu\u00e9 esta causando un bug en el programa. Para este ejercicio, necesitar\u00e1n la GDB reference card . GDB quiere decir \"GNU De-Bugger\". Compilen hello.c con la bandera \"-g\": 1 gcc -g -o hello hello.c Esto har\u00e1 que gcc guarde informaci\u00f3n en el archivo ejecutable para que gdb lo interprete. Ahora ejecuten el debugger, (c)gdb: 1 cgdb hello Vean lo que hace este comando. Est\u00e1n ejecutando el programa cgdb en el ejecutable hello generado por gcc . No intenten ejecutar cgdb en el archivo fuente en hello.c ! Eso no va a funcionar. Si cgdb no funciona, gdb se puede usar para completar los ejercicios (utilicen gdb hello ). Su tarea: ejecuten el programa varias veces haciendo esto: Poniendo un breakpoint en el main. Usando el comando run de gdb. Utilizando el comando single-step de gdb. Escriban help adentro de gdb para averiguar c\u00f3mo hacer estas cosas, o usen la reference card. Si encuentran un mensaje de error que dice: printf.c: No such file or directory . Probablemente entraron a una funci\u00f3n printf . Si siguen ejecutando paso a paso, pareciera que nunca avanzaran en el c\u00f3digo. CGDB est\u00e1 dando el error porque no tienen el archivo en el que se define la funci\u00f3n printf . Esto es algo molesto, y para librarse de esto, usen el comando finish para ejecutar el programa hasta que termine la funci\u00f3n printf. Y la pr\u00f3xima vez , utilicen el comando next para saltar sobre la linea que usa printf . Nota: CGDB vs GDB . En este ejercicio, usamos cgdb para depurar nuestros programas. cgdb es id\u00e9ntico a gdb, excepto que tiene unas caracter\u00edsticas extra que hacen m\u00e1s c\u00f3modo el trabajo. Todos los comandos de la hoja de referencia funcionan tambi\u00e9n en gdb. En cgdb, pueden presionar ESC para ir a la ventana del c\u00f3digo (arriba), y usar i para regresar a la ventana de comandos (abajo), similar a vim . La ventana de comandos es donde se introducen los comandos de gdb. Para este ejercicio, encontrar\u00e1n un archivo de texto llamado ex2.txt, con el siguiente formato: 1 2 3 4 5 6 7 8 9 1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : Aqu\u00ed tendr\u00e1n que responder las siguientes preguntas de opci\u00f3n m\u00faltiple (no tengan miedo de probar las opciones en CGDB antes de responder, \u00a1lo recomendamos!) con el siguiente formato (tienen que cambiar la letra en el ejemplo por la letra de la respuesta que ustedes consideren correcta): 1 2 3 4 5 6 7 8 9 1 :e 2 :f 3 :g 4 :h 5 :i 6 :j 7 :k 8 :l 9 :m Preguntas 1. \u00bfC\u00f3mo se le dan argumentos desde la l\u00ednea de comandos a un programa al utilizar gdb? a. args arglist b. run arglist c. gdb args d. Ninguna de las anteriores 2. \u00bfC\u00f3mo se a\u00f1ade un breakpoint que s\u00f3lo ocurre cuando se cumplen ciertas condiciones (por ejemplo, ciertas variables alcanzan cierto valor)? a. expr cond b. cond break expr c. break ... if expr d. Ninguna de las anteriores 3. \u00bfCon qu\u00e9 comando se ejecuta la siguiente l\u00ednea del c\u00f3digo en C despu\u00e9s de parar en un breakpoint? a. run b. s c. c d. n 4. Si la siguiente l\u00ednea de c\u00f3digo es una llamada a funci\u00f3n, \u00bfse ejecutar\u00eda toda la funci\u00f3n si se utiliza el comando de la pregunta #3? (si no, es momento de cambiarla!). \u00bfC\u00f3mo se le indica a gdb, que quieren debuggear el c\u00f3digo adentro de la funci\u00f3n ? (Si tuvieron que cambiar la respuesta #3, esa respuesta muy probablemente aplica aqu\u00ed) a. run b. s c. c d. n 5. \u00bfC\u00f3mo se reanuda la ejecuci\u00f3n del programa despu\u00e9s de parar en un breakpoint? a. run b. s c. c d. n 6. \u00bfC\u00f3mo podemos ver el valor de una variable (o expresi\u00f3n) en gdb? a. display expr b. signal expr c. print expr d. next expr 7. \u00bfQu\u00e9 comando de gdb se usa para desplegar el valor de una variable despu\u00e9s de cada paso ? a. display expr b. signal expr c. print expr d. next expr 8. \u00bfC\u00f3mo se imprime una lista de todas las variables y su valor en la funci\u00f3n actual? a. display all b. display c. print all d. print 9. \u00bfC\u00f3mo salimos de gdb? a. end b. quit c. exit d. finish Despu\u00e9s de responder estas preguntas, no olviden hacer el commit y push de este archivo hacia Github: 1 2 3 $ git add ex2.txt $ git commit -m \"Ejercicio 2 terminado\" $ git push -u origin main","title":"\u00bfQu\u00e9 es un debugger?"},{"location":"labs/lab01/#ejercicio-3-depurando-un-problema-con-fallas-usando-gdb","text":"Ahora, usar\u00e1n su nuevo conocimiento para depurar un peque\u00f1o programa. Vean el programa ll_equal.c . Compilen y ejecuten el programa, y analicen un poco lo que hace. As\u00ed como est\u00e1, producir\u00e1 un resultado como el siguiente: 1 2 3 4 $ gcc -g -o ll_equal ll_equal.c $ ./ll_equal equal test 1 result = 1 Segmentation fault Averig\u00fcen qu\u00e9 produce el segmentation fault (falla de segmentaci\u00f3n) . Ejecuten gdb en el programa, siguiendo las instrucciones aprendidas en los ejercicios anteriores. Les recomendamos a\u00f1adir un breakpoint en la funci\u00f3n ll_equal() . Cuando el debugger pare en el breakpoint, ejecuten paso a paso el programa, para que puedan descifrar qu\u00e9 es lo que provoca el error. Pista: Analicen el valor de los punteros a y b en la funci\u00f3n (\u00a1despli\u00e9guenlos!). \u00bfEst\u00e1n siempre apuntando a la direcci\u00f3n correcta? Pista 2: Vean el c\u00f3digo fuente en main para ver la estructura de los nodos y ver exactamente qu\u00e9 est\u00e1 pasando como argumento a ll_equal . Despu\u00e9s de corregir el problema, compilen nuevamente y ejecuten el c\u00f3digo. \u00bfNotan la diferencia? Al finalizar, no olviden subir el archivo modificado a su repositorio remoto: 1 2 3 $ git add ll_equal.c $ git commit -m \"Ejercicio 2 terminado\" $ git push -u origin main","title":"Ejercicio 3: Depurando un problema con fallas usando GDB"},{"location":"labs/lab01/#ejercicio-4-debuggeando-un-programa-en-c-que-requiere-interaccion-del-usuario","text":"Veamos qu\u00e9 pasa cuando, a un programa que requiere interacci\u00f3n del usuario, lo ejecutamos con gdb. Primero, ejecuten el programa en interactive_hello.c para hablar con un programa muy amigable :). 1 2 $ gcc -g -o int_hello interactive_hello.c $ ./int_hello Ahora, traten de depurarlo (aunque no haya ning\u00fan problema realmente): 1 $ cgdb int_hello \u00bfQu\u00e9 pasa cuando intentar ejecutar el programa hasta el final? Vamos a aprender acerca de una herramienta que nos ayudar\u00e1 a evitar este problema. El prop\u00f3sito de este ejercicio es que no tengan miedo de usar un debugger incluso cuando el programa requiera de interacci\u00f3n con el usuario. Resulta que es posible enviar texto a stdin , el flujo de datos que es le\u00eddo por la funci\u00f3n fgets en este programa, con unos caracteres especiales desde la l\u00ednea de comandos. Echen un vistazo a la \"redirecci\u00f3n\" en esta p\u00e1gina , y vean si pueden descifrar c\u00f3mo enviar texto al programa sin escribirlo textualmente mientras el programa est\u00e1 en ejecuci\u00f3n (lo cual, como ya saben, no funciona bien en CGDB). Pueden ver esta discusi\u00f3n de stackoverflow para m\u00e1s inspiraci\u00f3n. (Pista 1: \u00a1Si est\u00e1n creando un archivo de texto que contiene su input, van bien!) (pista 2: Recuerden que es posible ejecutar programas con argumentos (incluyendo s\u00edmbolos de redirecci\u00f3n) desde CGDB! Esperamos que hayan comprendido c\u00f3mo utilizar redirecci\u00f3n y c\u00f3mo es que esto les ayuda a evitar varios problemas al usar CGDB. \u00a1Nunca tengan miedo de usar un debugger ! Tal vez no es muy agradable visualmente, pero siempre estar\u00e1 para ayudarlos. Este ejercicio no vale puntos :-) pero es importante conocer sobre estas cosas para que puedan utilizarlo en el futuro (los siguientes laboratorios y proyectos podr\u00edan necesitar de este conocimiento)","title":"Ejercicio 4: \"Debuggeando\" un programa en C que requiere interacci\u00f3n del usuario"},{"location":"labs/lab01/#ejercicio-5-punteros-y-estructuras-en-c","text":"En ll cycle.c, completen la funci\u00f3n ll_has_cycle(), de modo que implemente el siguiente algoritmo para comprobar si una _linked list simple tiene un ciclo: Comiencen con dos punteros apuntando al principio de la lista. Llamaremos al primero tortoise (tortuga) y al segundo hare (liebre). Avancen el puntero hare dos nodos hacia adelante. Si no se puede debido a punteros null , hemos llegado al final de la lista. Por lo tanto, la lista no tiene un ciclo. Ahora, avancen tortoise un nodo. (Revisar si llega a ser un puntero nulo es innecesario. \u00bfPor qu\u00e9?) Si la tortuga y la liebre apuntan al mismo nodo, la lista es c\u00edclica. Si no, regresen al paso 2. Despu\u00e9s de implementar correctamente la funci\u00f3n ll_has_cycle() , el programa que se obtiene despu\u00e9s de compilar ll_cycle.c mostrar\u00e1 si el resultado de su funci\u00f3n est\u00e1 correcto, conforme a lo que esperaba como salida. Pista: Hay dos formas comunes en que los estudiantes resuelven esta funci\u00f3n, y la diferencia principal est\u00e1 en la forma en que deciden codificar el criterio de c\u00f3mo finalizar. Si lo hacen de una forma, tendr\u00edan que tomar en cuenta un caso especial en el principio. Si lo hacen de otra forma, tendr\u00edan que tener unas pruebas extra de NULL, lo cual esta bien tambi\u00e9n. Les decimos esto para que no se preocupen de la \"limpieza\" de su c\u00f3digo, si no les ayuda, simplemente ignoren esta pista. El punto de este ejercicio es asegurarse de que entiendan como usar punteros. Aqu\u00ed hay un Art\u00edculo del algoritmo y por qu\u00e9 funciona. No se preocupen de entender completamente todo (no hay examen de esto). A prop\u00f3sito, los punteros se llaman tortoise y hare porque el puntero \"tortoise (tortuga)\" se incrementa lentamente (como una tortuga, que se mueve muy lento) y el puntero \"hare (liebre)\" se incrementa r\u00e1pidamente (m\u00e1s r\u00e1pido que una tortuga, como una liebre, o conejo, que se mueve muy r\u00e1pido). Al finalizar, compilen y ejecuten el archivo, y verifiquen que el resultado de su c\u00f3digo, el cual deber\u00eda ser m\u00e1s o menos igual a este: 1 2 3 4 5 6 7 8 $ gcc -g -o ll_cycle ll_cycle.c $ ./ll_cycle Checking first list for cycles. There should be none, ll_has_cycle says it has no cycle Checking second list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking third list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking fourth list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking fifth list for cycles. There should be none, ll_has_cycle says it has no cycle Checking length-zero list for cycles. There should be none, ll_has_cycle says it has no cycle Si su c\u00f3digo presenta errores, entonces ya son capaces de utilizar CGDB para poder encontrarlos y corregirlos. Finalmente, pueden subir el archivo a github: 1 2 3 $ git add ll_cycle.c $ git commit -m \"LAB01 terminado\" $ git push -u origin main Para finalizar, la f\u00e1bula de la tortuga y la liebre es relevante siempre, especialmente en este curso. Escribir sus programas en C a paso lento pero seguro (ayud\u00e1ndose de programas como CGDB) es lo que les har\u00e1 ganar la carrera.","title":"Ejercicio 5: Punteros y estructuras en C"},{"location":"labs/lab01/#entrega-de-laboratorio","text":"A partir de este laboratorio contaremos con autograders, por lo que podr\u00e1 conocer su nota de inmediato. Para poder utilizarlo debemos realizar una pequena instalaci\u00f3n (todos, incluyendo a quienes bajaron nuestra m\u00e1quina virtual, los autograders est\u00e1n reci\u00e9n salidos del horno). Para instalar necesitamos tener Python 3.6 o superior, nuestra m\u00e1quina virtual ya lo cumple. Comenzamos con... 1 pip3 install autograders-cli Esto instala el modulo a traves del cual entregar\u00e1 su asignaci\u00f3n. Luego tenemos que registrarnos. Por favor sea MUY CUIDADOSO al ingresar sus datos. Como es usual en Linux no se vera su contrasena mientras la escribe, de momento NO EXISTE RECUPERACION DE CONTRASENA por si se equivoca o se le olvida. SEA MUY CUIDADOSO . 1 autograder --register Tras llenar su nombre completo, correo y crear su contrase\u00f1a se le enviar\u00e1 un correo. Haga click en el link que va en el correo (es posible que al hacer click se quede \"trabado\" en redirecting/redirigiendo, esto es normal, no se preocupe). Luego de hacer click en ese link, esta listo para entregar. Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json ; si aparecio, est\u00e1 en el lugar correcto. Ahora puede entregar su laboratorio con... 1 autograder --upload Espera un minuto aproximadamente y luego puede ver sus resultados con... 1 autograder --stats Vera desplegado sus resultados de esta manera (excepto que usted tendra 100 en lugar de 0 :P). Si dice Queued: True significa que el autograder esta un poquito ocupado y no le ha calificado, revise de nuevo en unos cinco minutos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ___ __ __ / _ | __ __/ /____ ___ ________ ____/ /__ _______ / __ / // / __/ _ \\/ _ ` / __/ _ ` / _ / -_ ) __ ( _- /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ /___/ Command Line Interface Autograders.org Get Task Stats - Queued: False - Grade: 0 .00/100 - Created At: 2021 -01-29T12:57:05.454Z - Updated At: 2021 -01-29T12:57:12.131Z Details: \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555 \u2502 Name \u2502 Grade \u2502 Message \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 1 . Eccentric \u2502 0 \u2502 incomplete: some answers are wrong... \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 2 . CGDB \u2502 0 \u2502 incomplete: q1,q2,q3,q4,q5,q6,q7,q8,q9 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 . ll_equal \u2502 0 \u2502 failed: runtime error \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 4 . ll_cycle \u2502 0 \u2502 failed: Failed some tests... \u2502 \u2558\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255b Felicidades! Termino su lab 1. Envie el link de su repo en el GES (el GES le permite enviar links, no pegue su link en un TXT u otro documento, es inc\u00f3modo).","title":"Entrega de laboratorio"},{"location":"labs/lab02/","text":"Lab 2 - C Avanzado y Manejo de Memoria Objetivos Manipular los bits de n\u00fameros binarios. Aprendan a utilizar sus nuevos poderes. Practicar trabajar con la asignaci\u00f3n de memoria de manera din\u00e1mica (esa cosa de malloc ). Aprovechar toda la memoria no utilizada. Pensar c\u00f3mo el manejo de memoria din\u00e1mica los puede hacer mejores personas. Son bromas, pero s\u00f3lo los puede volver mejores programadores. Preparaci\u00f3n De primero, deben de descargar todos los archivos que necesitar\u00e1n para completar este laboratorio, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario. Recuerden que este ser\u00e1 revisado en b\u00fasqueda de copia o plagio, as\u00ed que no lo hagan. De lo contrario, ser\u00e1 sancionado acorde al reglamento de la universidad. Ahora, ya pueden ejecutar en la terminal el comando que les descargar\u00e1 los archivos base en el directorio a su elecci\u00f3n: 1 git clone link_al_lab Ejercicio 1: Operando Bits Para este inciso, su trabajo es completar los archivos ex1/get_bit.c , ex1/set_bit.c y ex1/flip_bit.c de manera que las funciones cumplan con su tarea (as\u00ed como el nombre de las funciones sugiere). Para ello deber\u00e1n utilizar las operaciones de bits b\u00e1sicas: and (&), or (|), xor (^), not (~) y los corrimientos a la derecha (>>) y a la izquierda (<<). Deben evitar el uso de ciclos o condicionales. \u00a1\u00a1\u00a1\u00a1No usen ciclos ni condicionales!!!! Eso significa que mientras realicen el ejercicio no pueden y no deben de escribir las palabras: if, else, do, while, for, switch o algo de \u00edndole similar. Por favor no traten de enga\u00f1arnos, todo el personal involucrado (esperamos) sabe c\u00f3mo se miran todas estas palabras, entonces si encontramos una de ellas... El autograder analiza su c\u00f3digo de todas formas... \u00af\\_(\u30c4)_/\u00af sorry not sorry NOTA IMPORTANTE: Considerar que n es un valor que inicia en la posici\u00f3n cero, contando desde la derecha, por lo que el bit que se encuentra hasta la derecha es el bit cero. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Return the nth bit of x. // Assume 0 <= n <= 31 unsigned get_bit ( unsigned x , unsigned n ); // Set the nth bit of the value of x to v. // Assume 0 <= n <= 31, and v is 0 or 1 void set_bit ( unsigned * x , unsigned n , unsigned v ); // Flip the nth bit of the value of x. // Assume 0 <= n <= 31 void flip_bit ( unsigned * x , unsigned n ); Ayuda para set_bit : La parte complicada es no saber el valor del bit antes de cambiarlo. Pero, sabemos que 0 | x = x , pero \u00bfpodemos aprovecharnos de esto? \u00bfEs posible volverlo cero? Una vez terminen de editar las funciones, pueden compilar y correr el c\u00f3digo con: 1 2 make bit_ops ./bit_ops Lo cual imprimir\u00e1 el resultado de algunas pruebas. Si tienen curiosidad pueden revisar con libertad la carpeta tests/ que contiene las pruebas que se van a realizar en cada ejercicio de este laboratorio y que reflejan bastante lo que evaluar\u00e1 el autograder, por ejemplo el archivo que se utiliza para este ejercicio es tests/bit_ops_test.c . De ahora en adelante hasta que esten 100% seguros de que tienen completo el laboratorio o ya est\u00e9 cerca la hora de entregar su laboratorio, pueden mandar sus archivos como en los laboratorios pasados utilizando ./submit <TOKEN> . Acu\u00e9rdense de realizar el proceso de \"hacerle push\" al archivo para subirlo al repositorio de GitHub. Ejercicio 2: Registro de Corrimiento con Retroalimentaci\u00f3n Lineal En este ejercicio deben de implementar una funci\u00f3n que compute la siguiente iteraci\u00f3n de un registro de corrimiento de retroalimentaci\u00f3n lineal (LFSR por sus siglas en ingl\u00e9s). \u00a1Algunas aplicaciones que utilizan LFSRs son: televisi\u00f3n digital, tel\u00e9fonos con acceso m\u00faltiple por divisi\u00f3n de c\u00f3digo, Ethernet, USB 3.0 y mucho m\u00e1s! Esta funci\u00f3n deber\u00e1 generar n\u00fameros pseudo-aleatorios utilizando operadores binarios. Para un poco de informaci\u00f3n adicional, pueden visitar el siguiente link de Wikipedia . En el archivo ex2/lfsr_calculate.c deben de completar la funci\u00f3n lfsr_calculate() de manera que realice lo siguiente: Diagrama del Hardware (Explicaci\u00f3n M\u00e1s Abajo) Explicaci\u00f3n del Diagrama de Arriba En cada llamada de lfsr_calculate() , deben de correr el contenido del registro un bit hacia la derecha. Este corrimiento no es ni l\u00f3gico, ni aritm\u00e9tico. En el lado izquierdo deben de colocar un bit equivalente a un XOR de los bits que estaban, originalmente, en las posiciones 1, 3, 4 y 6. El objeto que parece un faro de autom\u00f3vil curvado es un XOR, el cual recibe dos entradas (a, b) y devuelve en su salida a^b. A diferencia del ejercicio 1, las posiciones de los bits inician con 1 . Despu\u00e9s que hayan implementado de manera correcta lfsr_calculate() , compilen y c\u00f3rranlo. Su respuesta debe ser similar a lo siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 make lfsr ./lfsr My number is: 1 My number is: 5185 My number is: 38801 My number is: 52819 My number is: 21116 My number is: 54726 My number is: 26552 My number is: 46916 My number is: 41728 My number is: 26004 My number is: 62850 My number is: 40625 My number is: 647 My number is: 12837 My number is: 7043 My number is: 26003 My number is: 35845 My number is: 61398 My number is: 42863 My number is: 57133 My number is: 59156 My number is: 13312 My number is: 16285 ... etc etc ... Got 65535 numbers before cycling! Congratulations! It works! De nuevo, recu\u00e9rdense de hacer el push. Ejercicio 3: Manejo de Memoria Este ejercicio requiere de los archivos: tests/include/vector.h , tests/vector_test.c y ex3/vector.c , en donde les proveemos con la base para la implementaci\u00f3n de un arreglo de longitud variable. Este inciso busca que se familiaricen con el uso de los \"structs\" de C, as\u00ed como el manejo de memoria en este lenguaje. En otras palabras, no se preocupen por los detalles pr\u00e1cticos de esta estructura de datos un tanto extra\u00f1a. S\u00f3lo no lo hagan. Su trabajo es completar las funciones vector_new() , vector_get() , vector_delete() y vector_set() en ex3/vector.c de manera que tests/vector-test.c corra sin errores de manejo de memoria. \u00bfC\u00f3mo funciona un vector_t ? Posee un int size que indica cu\u00e1ntos elementos posee actualmente. En otras palabras, el size es igual al \u00edndice de la \u00faltima posici\u00f3n que ha sido alterada del vector. Por ejemplo, si se tiene un vector con un size de 5 y se altera su ducent\u00e9cimo bit (\u00edndice iniciando en cero), su tama\u00f1o se ver\u00e1 actualizado a 201. La longitud por defecto del vector vector_new es de 1. Tiene un int *data , un arreglo din\u00e1mico de enteros que contiene los valores de los componentes del vector. Si se altera el ducent\u00e9cimo elemento de un vector v a 8 entonces el elemento modificado (de nuevo, iniciando en cero) de v->data deber\u00eda evaluar a 8. El valor de un vector vector_new es 0 por defecto. El valor de cualquier componente de alg\u00fan vector que no ha sido expl\u00edcitamente editado es 0. Si se deseara conocer el valor en la quinta posici\u00f3n de un vector, pero s\u00f3lo se ha alterado el valor de los primeras dos, la interrogante tendr\u00eda como respuesta 0. Adem\u00e1s, si se quisiera el contenido en la s\u00e9ptima posici\u00f3n de un vector de longitud igual a 5, tambi\u00e9n ser\u00eda 0. NO devolver\u00eda un error. Es momento de revisar el c\u00f3digo de ex3/vector.c si no lo han hecho. Aqu\u00ed hay comentarios complementarios que describen c\u00f3mo deber\u00edan de correr las funciones. Recuerden que los usuarios de su estructura de datos vector_t deben asumir que todas las entradas al vector son 0, a menos que hayan sido definidas de otra manera por ellos. Tengan esto en mente, porque malloc no hace esto por ustedes. \u00bfQu\u00e9 deben hacer? Completen vector_new , la versi\u00f3n correcta. Hay exactamente seis (6) espacios para que escriban una expresi\u00f3n en C, indicados con el comentario que dice /* YOUR CODE HERE */ . Escriban una expresi\u00f3n en estos sitios. Esto significa no m\u00e1s de una l\u00ednea de c\u00f3digo. Existen comentarios adicionales que describen qu\u00e9 deber\u00eda de suceder en la l\u00ednea de c\u00f3digo inferior a cada divisi\u00f3n. Terminen vector_get() de la misma manera en que lo hicieron para la funci\u00f3n anterior: de manera respetuosa, dispuesto a aprender, con mente abierta y conscientes de qu\u00e9 es lo que est\u00e1n escribiendo, ya que esta es la mejor forma de programar. Complementen vector_delete() . Una soluci\u00f3n satisfactoria no deber\u00eda de llevar m\u00e1s de dos l\u00edneas de c\u00f3digo. Corrijan a vector_set() . Esta es la m\u00e1s complicada. Bienvenidos a las ligas mayores. El problema de manipular una posici\u00f3n/\u00edndice arbitrario en un vector v es que es posible que no se haya reservado suficiente espacio con malloc en vector->data (s\u00ed, eso significa que tuvieron que haber guardado memoria con malloc ). Piensen c\u00f3mo administrar la memoria para lograr esto, para ver qu\u00e9 hacer con la data que estaba ah\u00ed antes y de qu\u00e9 otras cosas deben de hacer en su nuevo bloque de datos. Ayuda: Recuerden que los \u00edndices que no hayan sido alterados deben de ser cero. Hay distintas formas de acabar resolviendo esta funci\u00f3n. Consideren el uso de las 3 funciones __alloc , porque pueden resultar \u00fatiles... Saber c\u00f3mo reorganizar y liberar memoria es importante para la programaci\u00f3n en C. Piensen que el manejo de memoria es como un parqueo, si hay carros parqueados y los due\u00f1os nunca se van, entonces no tienen espacio para nuevos carros. Y recuerden que deber\u00edan tener un 'heap' vac\u00edo al terminar su programa. Utilicen free y todo estar\u00e1 bien. Calificaci\u00f3n Por favor actualizar siempre la versi\u00f3n del CLI de autograders: 1 pip3 install --upgrade autograders-cli Como en todos los dem\u00e1s laboratorios, hay un autograder y este no es la excepci\u00f3n. El staff trabajo bastante para que su experiencia en este curso sea de las mejores. Entregaremos este lab de la misma manera que el pasado. Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json; si aparecio, esta en el lugar correcto. Ahora puede entregar su laboratorio con... 1 autograder --upload Espera un minuto aprox. y luego puede ver sus resultados con... 1 autograder --stats Si le aparece Queued: True, espere un par de minutos y luego repita el autograder --stats \u00fanicamente. Al terminar todo, suba el link de su repositorio al GES.","title":"02: C Avanzado"},{"location":"labs/lab02/#lab-2-c-avanzado-y-manejo-de-memoria","text":"","title":"Lab 2 - C Avanzado y Manejo de Memoria"},{"location":"labs/lab02/#objetivos","text":"Manipular los bits de n\u00fameros binarios. Aprendan a utilizar sus nuevos poderes. Practicar trabajar con la asignaci\u00f3n de memoria de manera din\u00e1mica (esa cosa de malloc ). Aprovechar toda la memoria no utilizada. Pensar c\u00f3mo el manejo de memoria din\u00e1mica los puede hacer mejores personas. Son bromas, pero s\u00f3lo los puede volver mejores programadores.","title":"Objetivos"},{"location":"labs/lab02/#preparacion","text":"De primero, deben de descargar todos los archivos que necesitar\u00e1n para completar este laboratorio, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario. Recuerden que este ser\u00e1 revisado en b\u00fasqueda de copia o plagio, as\u00ed que no lo hagan. De lo contrario, ser\u00e1 sancionado acorde al reglamento de la universidad. Ahora, ya pueden ejecutar en la terminal el comando que les descargar\u00e1 los archivos base en el directorio a su elecci\u00f3n: 1 git clone link_al_lab","title":"Preparaci\u00f3n"},{"location":"labs/lab02/#ejercicio-1-operando-bits","text":"Para este inciso, su trabajo es completar los archivos ex1/get_bit.c , ex1/set_bit.c y ex1/flip_bit.c de manera que las funciones cumplan con su tarea (as\u00ed como el nombre de las funciones sugiere). Para ello deber\u00e1n utilizar las operaciones de bits b\u00e1sicas: and (&), or (|), xor (^), not (~) y los corrimientos a la derecha (>>) y a la izquierda (<<). Deben evitar el uso de ciclos o condicionales. \u00a1\u00a1\u00a1\u00a1No usen ciclos ni condicionales!!!! Eso significa que mientras realicen el ejercicio no pueden y no deben de escribir las palabras: if, else, do, while, for, switch o algo de \u00edndole similar. Por favor no traten de enga\u00f1arnos, todo el personal involucrado (esperamos) sabe c\u00f3mo se miran todas estas palabras, entonces si encontramos una de ellas... El autograder analiza su c\u00f3digo de todas formas... \u00af\\_(\u30c4)_/\u00af sorry not sorry NOTA IMPORTANTE: Considerar que n es un valor que inicia en la posici\u00f3n cero, contando desde la derecha, por lo que el bit que se encuentra hasta la derecha es el bit cero. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Return the nth bit of x. // Assume 0 <= n <= 31 unsigned get_bit ( unsigned x , unsigned n ); // Set the nth bit of the value of x to v. // Assume 0 <= n <= 31, and v is 0 or 1 void set_bit ( unsigned * x , unsigned n , unsigned v ); // Flip the nth bit of the value of x. // Assume 0 <= n <= 31 void flip_bit ( unsigned * x , unsigned n ); Ayuda para set_bit : La parte complicada es no saber el valor del bit antes de cambiarlo. Pero, sabemos que 0 | x = x , pero \u00bfpodemos aprovecharnos de esto? \u00bfEs posible volverlo cero? Una vez terminen de editar las funciones, pueden compilar y correr el c\u00f3digo con: 1 2 make bit_ops ./bit_ops Lo cual imprimir\u00e1 el resultado de algunas pruebas. Si tienen curiosidad pueden revisar con libertad la carpeta tests/ que contiene las pruebas que se van a realizar en cada ejercicio de este laboratorio y que reflejan bastante lo que evaluar\u00e1 el autograder, por ejemplo el archivo que se utiliza para este ejercicio es tests/bit_ops_test.c . De ahora en adelante hasta que esten 100% seguros de que tienen completo el laboratorio o ya est\u00e9 cerca la hora de entregar su laboratorio, pueden mandar sus archivos como en los laboratorios pasados utilizando ./submit <TOKEN> . Acu\u00e9rdense de realizar el proceso de \"hacerle push\" al archivo para subirlo al repositorio de GitHub.","title":"Ejercicio 1: Operando Bits"},{"location":"labs/lab02/#ejercicio-2-registro-de-corrimiento-con-retroalimentacion-lineal","text":"En este ejercicio deben de implementar una funci\u00f3n que compute la siguiente iteraci\u00f3n de un registro de corrimiento de retroalimentaci\u00f3n lineal (LFSR por sus siglas en ingl\u00e9s). \u00a1Algunas aplicaciones que utilizan LFSRs son: televisi\u00f3n digital, tel\u00e9fonos con acceso m\u00faltiple por divisi\u00f3n de c\u00f3digo, Ethernet, USB 3.0 y mucho m\u00e1s! Esta funci\u00f3n deber\u00e1 generar n\u00fameros pseudo-aleatorios utilizando operadores binarios. Para un poco de informaci\u00f3n adicional, pueden visitar el siguiente link de Wikipedia . En el archivo ex2/lfsr_calculate.c deben de completar la funci\u00f3n lfsr_calculate() de manera que realice lo siguiente:","title":"Ejercicio 2: Registro de Corrimiento con Retroalimentaci\u00f3n Lineal"},{"location":"labs/lab02/#diagrama-del-hardware-explicacion-mas-abajo","text":"","title":"Diagrama del Hardware (Explicaci\u00f3n M\u00e1s Abajo)"},{"location":"labs/lab02/#explicacion-del-diagrama-de-arriba","text":"En cada llamada de lfsr_calculate() , deben de correr el contenido del registro un bit hacia la derecha. Este corrimiento no es ni l\u00f3gico, ni aritm\u00e9tico. En el lado izquierdo deben de colocar un bit equivalente a un XOR de los bits que estaban, originalmente, en las posiciones 1, 3, 4 y 6. El objeto que parece un faro de autom\u00f3vil curvado es un XOR, el cual recibe dos entradas (a, b) y devuelve en su salida a^b. A diferencia del ejercicio 1, las posiciones de los bits inician con 1 . Despu\u00e9s que hayan implementado de manera correcta lfsr_calculate() , compilen y c\u00f3rranlo. Su respuesta debe ser similar a lo siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 make lfsr ./lfsr My number is: 1 My number is: 5185 My number is: 38801 My number is: 52819 My number is: 21116 My number is: 54726 My number is: 26552 My number is: 46916 My number is: 41728 My number is: 26004 My number is: 62850 My number is: 40625 My number is: 647 My number is: 12837 My number is: 7043 My number is: 26003 My number is: 35845 My number is: 61398 My number is: 42863 My number is: 57133 My number is: 59156 My number is: 13312 My number is: 16285 ... etc etc ... Got 65535 numbers before cycling! Congratulations! It works! De nuevo, recu\u00e9rdense de hacer el push.","title":"Explicaci\u00f3n del Diagrama de Arriba"},{"location":"labs/lab02/#ejercicio-3-manejo-de-memoria","text":"Este ejercicio requiere de los archivos: tests/include/vector.h , tests/vector_test.c y ex3/vector.c , en donde les proveemos con la base para la implementaci\u00f3n de un arreglo de longitud variable. Este inciso busca que se familiaricen con el uso de los \"structs\" de C, as\u00ed como el manejo de memoria en este lenguaje. En otras palabras, no se preocupen por los detalles pr\u00e1cticos de esta estructura de datos un tanto extra\u00f1a. S\u00f3lo no lo hagan. Su trabajo es completar las funciones vector_new() , vector_get() , vector_delete() y vector_set() en ex3/vector.c de manera que tests/vector-test.c corra sin errores de manejo de memoria.","title":"Ejercicio 3: Manejo de Memoria"},{"location":"labs/lab02/#como-funciona-un-vector_t","text":"Posee un int size que indica cu\u00e1ntos elementos posee actualmente. En otras palabras, el size es igual al \u00edndice de la \u00faltima posici\u00f3n que ha sido alterada del vector. Por ejemplo, si se tiene un vector con un size de 5 y se altera su ducent\u00e9cimo bit (\u00edndice iniciando en cero), su tama\u00f1o se ver\u00e1 actualizado a 201. La longitud por defecto del vector vector_new es de 1. Tiene un int *data , un arreglo din\u00e1mico de enteros que contiene los valores de los componentes del vector. Si se altera el ducent\u00e9cimo elemento de un vector v a 8 entonces el elemento modificado (de nuevo, iniciando en cero) de v->data deber\u00eda evaluar a 8. El valor de un vector vector_new es 0 por defecto. El valor de cualquier componente de alg\u00fan vector que no ha sido expl\u00edcitamente editado es 0. Si se deseara conocer el valor en la quinta posici\u00f3n de un vector, pero s\u00f3lo se ha alterado el valor de los primeras dos, la interrogante tendr\u00eda como respuesta 0. Adem\u00e1s, si se quisiera el contenido en la s\u00e9ptima posici\u00f3n de un vector de longitud igual a 5, tambi\u00e9n ser\u00eda 0. NO devolver\u00eda un error. Es momento de revisar el c\u00f3digo de ex3/vector.c si no lo han hecho. Aqu\u00ed hay comentarios complementarios que describen c\u00f3mo deber\u00edan de correr las funciones. Recuerden que los usuarios de su estructura de datos vector_t deben asumir que todas las entradas al vector son 0, a menos que hayan sido definidas de otra manera por ellos. Tengan esto en mente, porque malloc no hace esto por ustedes.","title":"\u00bfC\u00f3mo funciona un vector_t?"},{"location":"labs/lab02/#que-deben-hacer","text":"Completen vector_new , la versi\u00f3n correcta. Hay exactamente seis (6) espacios para que escriban una expresi\u00f3n en C, indicados con el comentario que dice /* YOUR CODE HERE */ . Escriban una expresi\u00f3n en estos sitios. Esto significa no m\u00e1s de una l\u00ednea de c\u00f3digo. Existen comentarios adicionales que describen qu\u00e9 deber\u00eda de suceder en la l\u00ednea de c\u00f3digo inferior a cada divisi\u00f3n. Terminen vector_get() de la misma manera en que lo hicieron para la funci\u00f3n anterior: de manera respetuosa, dispuesto a aprender, con mente abierta y conscientes de qu\u00e9 es lo que est\u00e1n escribiendo, ya que esta es la mejor forma de programar. Complementen vector_delete() . Una soluci\u00f3n satisfactoria no deber\u00eda de llevar m\u00e1s de dos l\u00edneas de c\u00f3digo. Corrijan a vector_set() . Esta es la m\u00e1s complicada. Bienvenidos a las ligas mayores. El problema de manipular una posici\u00f3n/\u00edndice arbitrario en un vector v es que es posible que no se haya reservado suficiente espacio con malloc en vector->data (s\u00ed, eso significa que tuvieron que haber guardado memoria con malloc ). Piensen c\u00f3mo administrar la memoria para lograr esto, para ver qu\u00e9 hacer con la data que estaba ah\u00ed antes y de qu\u00e9 otras cosas deben de hacer en su nuevo bloque de datos. Ayuda: Recuerden que los \u00edndices que no hayan sido alterados deben de ser cero. Hay distintas formas de acabar resolviendo esta funci\u00f3n. Consideren el uso de las 3 funciones __alloc , porque pueden resultar \u00fatiles... Saber c\u00f3mo reorganizar y liberar memoria es importante para la programaci\u00f3n en C. Piensen que el manejo de memoria es como un parqueo, si hay carros parqueados y los due\u00f1os nunca se van, entonces no tienen espacio para nuevos carros. Y recuerden que deber\u00edan tener un 'heap' vac\u00edo al terminar su programa. Utilicen free y todo estar\u00e1 bien.","title":"\u00bfQu\u00e9 deben hacer?"},{"location":"labs/lab02/#calificacion","text":"Por favor actualizar siempre la versi\u00f3n del CLI de autograders: 1 pip3 install --upgrade autograders-cli Como en todos los dem\u00e1s laboratorios, hay un autograder y este no es la excepci\u00f3n. El staff trabajo bastante para que su experiencia en este curso sea de las mejores. Entregaremos este lab de la misma manera que el pasado. Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json; si aparecio, esta en el lugar correcto. Ahora puede entregar su laboratorio con... 1 autograder --upload Espera un minuto aprox. y luego puede ver sus resultados con... 1 autograder --stats Si le aparece Queued: True, espere un par de minutos y luego repita el autograder --stats \u00fanicamente. Al terminar todo, suba el link de su repositorio al GES.","title":"Calificaci\u00f3n"},{"location":"labs/lab03/","text":"Lab 3 - RISC-V Objetivos Practicar, corriendo y debuggeando c\u00f3digo ensamblador RISC-V. Escribir funciones en RISC-V con el procedimiento correcto de llamadas a funciones. Tener una idea de como traducir c\u00f3digo en C a RISC-V. Lecturas P&H: 2.12 Preparaci\u00f3n Para comenzar con el laboratorio primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): 1 git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3. Introducci\u00f3n a Lenguaje Ensamblador RISC-V Los siguientes ejercicios utilizan un ensamblador y simulador de RISC-V, desarrollado por nuestro catedr\u00e1tico Ing. Andr\u00e9s Castellanos . El simulador se llama Jupiter (anteriormente V-Sim) y es un proyecto open source inspirado, inicialmente, en el lengendario SPIM y, posteriormente, en MARS y VENUS para la versi\u00f3n gr\u00e1fica. Para instalarlo en su computadora deben seguir estas instrucciones. M\u00e1quina virtual del curso Felicidades! No necesita instalar nada, puede ejecutar Jupiter usando el siguiente comando 1 jupiter Ubuntu 18 Debe instalar Jupiter usando estos comandos 1 2 3 sudo add-apt-repository ppa:andrescv/jupiter sudo apt-get update sudo apt-get install jupiter Luego podr\u00e1 ejecutarlo usando el comando jupiter Ubuntu 20 Descargar este archivo . Ir a la carpeta donde lo descarg\u00f3 y ejecutar los siguientes comandos 1 2 3 4 unzip Jupiter-3.1-linux.zip sudo mv image /opt/jupiter echo export\\ PATH=/opt/jupiter/bin:\\$PATH >> ~/.bashrc source ~/.bashrc Despu\u00e9s de esto, ya deber\u00eda poder usar el comando jupiter . Si no, la vieja y confiable, reinicie su computadora. Cosas b\u00e1sicas en V-Sim: A continuaci\u00f3n, les vamos a dar una peque\u00f1a gu\u00eda de Jupiter, para m\u00e1s informaci\u00f3n visiten la p\u00e1gina de documentaci\u00f3n en https://jupitersim.gitbook.io/jupiter/ . Pueden crear archivos, editarlos y borrarlos desde la pesta\u00f1a \"Editor\". Los programas empiezan en la etiqueta global __start , es decir que tienen que definir una etiqueta llamada __start y declararla como global. 1 2 3 4 .globl __start __start: li a0 , 10 ecall # exit Las etiquetas terminan con dos puntos como ven en el ejemplo anterior. Los comentarios comienzan con el simbolo \"#\" o \";\". NO PUEDEN poner m\u00e1s de una instrucci\u00f3n por l\u00ednea. Cuando hayan terminado de editar las instrucciones que conforman su c\u00f3digo, guarden y presionen F3 para preparar la ejecuci\u00f3n. Los programas siempre tienen que terminar con un ecall de exit y esto se logra poniendo un 10 en a0 ( exactamente como el ejemplo anterior ). Esto le indica al programa que tiene que terminar. Las instrucciones ecall son an\u00e1logas a los \"System Calls\" (llamadas al sistema) y nos permiten hacer cosas como imprimir a consola o reservar memoria din\u00e1mica. Ejercicio 1: Familiariz\u00e1ndote con Jupiter Para este ejercicio ustedes van a familiarizarse con Jupiter corriendo un programa sencillo de RISC-V y, luego, contestar\u00e1n unas preguntas. Abran una terminal ( CTRL + T ) y dir\u00edjanse a la carpeta del repositorio que clonaron. Abran el modo GUI de V-Sim ejecutando en la terminal jupiter . Desde el editor abran el archivo llamado ex1.s que esta en la carpeta ex1 . En la barra de herramientas de Jupiter, vayan a settings y aseg\u00farense de que Assemble Only Selected Tab est\u00e9 seleccionado con un cheque verde. Presionen F3 . Esto va a preparar el c\u00f3digo para que pueda ser ejecutado y simulado. Si hacen click a la pesta\u00f1a \"Editor\", su simulaci\u00f3n se va a reiniciar. En el simulador, para ejecutar la siguiente instrucci\u00f3n, presionen el bot\u00f3n que dice \"step\". Para regresar un paso atr\u00e1s, presionen el bot\u00f3n que dice \"backstep\". Para correr todo el programa hasta que termine, presionen el bot\u00f3n que dice \"go\". Para volver a empezar el programa nuevamente, presionen el bot\u00f3n que dice \"reset\". Para ver el contenido de los 32 registros en la parte derecha del simulador, hay una pesta\u00f1a que dice RVI . La consola est\u00e1 en la parte de abajo del simulador. Para ver el contenido de la memoria, en el mismo lugar que los registros hay una pesta\u00f1a que dice Memory , pueden navegar a diferentes secciones de la memoria haciendo click derecho encima de la tabla que muestra el estado de la memoria. Preguntas Ahora que ya han corrido su primer programa de RISC-V y que ganaron experiencia con Jupiter pueden contestar las siguientes preguntas en el archivo ex1.txt que se encuentra en la carpeta ex1 . 1) \u00bfQu\u00e9 significan las directivas .data , .word , .text , es decir, para qu\u00e9 las utilizan? Escriban s\u00f3lo una de las siguientes letras para responder. Pista: Piensen acerca de las cuatro secciones de memoria. A) Son como etiquetas sirven para hacer referencia a cosas que est\u00e1n en memoria, con .data apuntamos hacia los datos con .word hacia palabras de 32 bits y con .text hacia texto. B) .data le indica al ensamblador que guarde los siguientes elementos en la secci\u00f3n est\u00e1tica de la memoria, .word que guarde una palabra de 32 bits en memoria en la secci\u00f3n est\u00e1tica de datos y .text que estamos en la secci\u00f3n de texto y entonces deber\u00edamos escribir instrucciones de ensamblador. C) .data es para guardar datos en la secci\u00f3n de datos de la memoria, .word es para guardar palabras de 32 bits en la secci\u00f3n de palabras de la memoria, .text es para guardar texto ascii en la secci\u00f3n de texto de la memoria. D) .data y .word no son directivas de ensamblador, y .text siempre est\u00e1 por defecto y ni se tendr\u00eda que poner. 2) Corran por completo el programa. \u00bfQu\u00e9 n\u00famero da como \"output\"? 3) \u00bfQu\u00e9 representa el n\u00famero que da como output el programa? Escriban s\u00f3lo una de las siguientes letras para responder: A) N\u00famero \u00e1ureo B) Factorial de 9 C) Fibonnaci de 9 D) Factorial de 10 4) \u00bfEn qu\u00e9 direcci\u00f3n de memoria (en hexadecimal) est\u00e1 almacenado \"n\"? Pista: Miren el contenido de los registros. 5) Sin utilizar la pesta\u00f1a \"Editor\", hagan que el programa calcule el 13\u00ba n\u00famero (tomando en cuenta que el \u00edndice empieza en 0) de la sucesi\u00f3n de Fibonacci, modificando manualmente el valor de un registro. Encontrar\u00e1n \u00fatil de primero correr l\u00ednea por l\u00ednea el c\u00f3digo. Si prefieren ver los valores en decimal, cambien esto haciendo click derecho sobre la tabla de registros y presionando \"Decimal Display Mode\". \u00bfQu\u00e9 registro modificaron? Ejercicio 2: Traduciendo de C a RISC-V Desde Jupiter abran el archivo ex2.s que est\u00e1 en la carpeta ex2 y, desde alg\u00fan editor de texto de su preferencia, abran ex2.c , que est\u00e1 en la misma carpeta. El c\u00f3digo ensamblador que se provee (archivo ex2.s) es una traducci\u00f3n del programa escrito en C (archivo ex2.c) pero en RISC-V. Su tarea es encontrar/explicar los siguientes componentes de este archivo escrito en lenguaje ensamblador en el archivo de texto llamado ex2.txt , que tambi\u00e9n est\u00e1 en la misma carpeta. Preguntas \u00bfCu\u00e1l es el registro que representa la variable k ? \u00bfCu\u00e1les son los registros que act\u00faan como punteros a los arreglos source y dest (separados por coma)? \u00bfDe qu\u00e9 n\u00famero de l\u00ednea a que n\u00famero l\u00ednea se encuentra el loop (separado por coma)? \u00bfEn qu\u00e9 n\u00famero de l\u00ednea se copia el contenido de source a dest ?, es decir \u00bfd\u00f3nde se puede observar dest[k] = source[k] ?. \u00bfC\u00f3mo son manipulados los punteros en el c\u00f3digo? Escriban s\u00f3lo una de las siguientes letras para responder: A) En cada iteraci\u00f3n se le suma k a cada puntero, que es el equivalente en C a arreglo[k] . B) En cada iteraci\u00f3n se le suma k * 4 a cada puntero, que es equivalente en C a arreglo[k] . C) En cada iteraci\u00f3n se le hace corrimiento l\u00f3gico a la derecha a cada puntero, que es equivalente en C a arreglo[k] . D) En cada iteraci\u00f3n se le suma +1 a cada puntero, que es equivalente en C a arreglo[k] . Ejercicio 3: Factorial. En este ejercicio, tienen que implementar la funci\u00f3n de factorial en RISC-V que toma un s\u00f3lo par\u00e1metro entero n y retorna n! . Pueden encontrar un esqueleto de esta funci\u00f3n en el archivo factorial.s , que se encuentra en la carpeta ex3 del repositorio que clonaron. Ustedes s\u00f3lo necesitan agregar las instrucciones bajo la etiqueta factorial , y el argumento que se pasa a la funci\u00f3n va en el registro a0 . Pueden resolver este problema ya sea de forma recursiva o iterativa. Aseg\u00farense de que su funci\u00f3n retorne de forma apropidada lo siguiente 3! = 6 , 7! = 5040 y 8! = 40320 . Ejercicio 4: List Map Para este ejercicio van a utilizar el archivo list_map.s que se encuentra en la carpeta ex4 . En este ejercicio, van a completar una funci\u00f3n de \"map\" con listas encadenadas en RISC-V. La funci\u00f3n se simplificar\u00e1 en mutar la lista en cuesti\u00f3n, es decir que tomar\u00e1 una lista encadenada como entrada y va a retornar la lista con los valores modificados. Nuestro procedimiento de \"map\" toma dos par\u00e1metros, el primero ser\u00e1 la direcci\u00f3n del nodo \"head\" de una lista encadenada, cuyos valores son enteros de 32 bits. Entonces, en C, la estructura se define como: 1 2 3 4 struct node { int value ; struct node * next ; }; El segundo par\u00e1metro ser\u00e1 la direcci\u00f3n de una funci\u00f3n que toma un entero como argumento y devuelve un entero. Usaremos la instrucci\u00f3n \"jalr\" de RISC-V para llamar a esta funci\u00f3n con los valores de cada nodo de la lista. Nuestra funci\u00f3n \"map\" ir\u00e1 recorriendo la lista recursivamente, aplicando la funci\u00f3n a cada valor de la lista y almacenando el valor devuelto al nodo correspondiente. En C, la funci\u00f3n se ver\u00eda algo como esta: 1 2 3 4 5 void map ( struct node * head , int ( * f )( int )) { if ( ! head ) { return ; } head -> value = f ( head -> value ); map ( head -> next , f ); } Si no hab\u00edan visto lo de int (*f)(int) antes, no se preocupen demasiado. Significa b\u00e1sicamente que f es un puntero a una funci\u00f3n de C, f entonces puede ser utilizado exactamente como cualquier otra funci\u00f3n. Les ser\u00e1 \u00fatil acudir al green card de RISC-V que pueden encontrar aqu\u00ed para completar este ejercicio. Hay exactamente 9 espacios (8 en map y 1 en main ), en el c\u00f3digo que se provee, donde dice YOUR_INSTRUCTION_HERE . Reemplacen esos espacios con las instrucciones de su implementaci\u00f3n de map, y escriban una simple llamada a map con square como argumento de la funci\u00f3n. Hay comentarios en el c\u00f3digo que explican qu\u00e9 deber\u00eda hacer, o cumplir, cada instrucci\u00f3n. Cuando hayan rellenado los espacios con las instrucciones correctas, pueden correr el c\u00f3digo pulsando en F3 y luego el bot\u00f3n Go , al hacer esto, deber\u00eda de darles como output lo siguiente: 1 2 9 8 7 6 5 4 3 2 1 0 81 64 49 36 25 16 9 4 1 0 La primera l\u00ednea es la lista original, y la segunda es la lista modificada despu\u00e9s de que se aplic\u00f3 la funci\u00f3n \"map\". Calificaci\u00f3n Por favor actualizar siempre la versi\u00f3n del CLI de autograders: 1 pip3 install --upgrade autograders-cli Como en todos los dem\u00e1s laboratorios, hay un autograder y este no es la excepci\u00f3n. El staff trabajo bastante para que su experiencia en este curso sea de las mejores. Entregaremos este lab de la misma manera que el pasado. Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json; si aparecio, esta en el lugar correcto. Ahora puede entregar su laboratorio con... 1 autograder --upload Espera un minuto aprox. y luego puede ver sus resultados con... 1 autograder --stats Si le aparece Queued: True, espere un par de minutos y luego repita el autograder --stats \u00fanicamente. Al terminar todo, suba el link de su repositorio al GES.","title":"03: Intro RISC-V"},{"location":"labs/lab03/#lab-3-risc-v","text":"","title":"Lab 3 - RISC-V"},{"location":"labs/lab03/#objetivos","text":"Practicar, corriendo y debuggeando c\u00f3digo ensamblador RISC-V. Escribir funciones en RISC-V con el procedimiento correcto de llamadas a funciones. Tener una idea de como traducir c\u00f3digo en C a RISC-V.","title":"Objetivos"},{"location":"labs/lab03/#lecturas","text":"P&H: 2.12","title":"Lecturas"},{"location":"labs/lab03/#preparacion","text":"Para comenzar con el laboratorio primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): 1 git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3.","title":"Preparaci\u00f3n"},{"location":"labs/lab03/#introduccion-a-lenguaje-ensamblador-risc-v","text":"Los siguientes ejercicios utilizan un ensamblador y simulador de RISC-V, desarrollado por nuestro catedr\u00e1tico Ing. Andr\u00e9s Castellanos . El simulador se llama Jupiter (anteriormente V-Sim) y es un proyecto open source inspirado, inicialmente, en el lengendario SPIM y, posteriormente, en MARS y VENUS para la versi\u00f3n gr\u00e1fica. Para instalarlo en su computadora deben seguir estas instrucciones. M\u00e1quina virtual del curso Felicidades! No necesita instalar nada, puede ejecutar Jupiter usando el siguiente comando 1 jupiter Ubuntu 18 Debe instalar Jupiter usando estos comandos 1 2 3 sudo add-apt-repository ppa:andrescv/jupiter sudo apt-get update sudo apt-get install jupiter Luego podr\u00e1 ejecutarlo usando el comando jupiter Ubuntu 20 Descargar este archivo . Ir a la carpeta donde lo descarg\u00f3 y ejecutar los siguientes comandos 1 2 3 4 unzip Jupiter-3.1-linux.zip sudo mv image /opt/jupiter echo export\\ PATH=/opt/jupiter/bin:\\$PATH >> ~/.bashrc source ~/.bashrc Despu\u00e9s de esto, ya deber\u00eda poder usar el comando jupiter . Si no, la vieja y confiable, reinicie su computadora.","title":"Introducci\u00f3n a Lenguaje Ensamblador RISC-V"},{"location":"labs/lab03/#cosas-basicas-en-v-sim","text":"A continuaci\u00f3n, les vamos a dar una peque\u00f1a gu\u00eda de Jupiter, para m\u00e1s informaci\u00f3n visiten la p\u00e1gina de documentaci\u00f3n en https://jupitersim.gitbook.io/jupiter/ . Pueden crear archivos, editarlos y borrarlos desde la pesta\u00f1a \"Editor\". Los programas empiezan en la etiqueta global __start , es decir que tienen que definir una etiqueta llamada __start y declararla como global. 1 2 3 4 .globl __start __start: li a0 , 10 ecall # exit Las etiquetas terminan con dos puntos como ven en el ejemplo anterior. Los comentarios comienzan con el simbolo \"#\" o \";\". NO PUEDEN poner m\u00e1s de una instrucci\u00f3n por l\u00ednea. Cuando hayan terminado de editar las instrucciones que conforman su c\u00f3digo, guarden y presionen F3 para preparar la ejecuci\u00f3n. Los programas siempre tienen que terminar con un ecall de exit y esto se logra poniendo un 10 en a0 ( exactamente como el ejemplo anterior ). Esto le indica al programa que tiene que terminar. Las instrucciones ecall son an\u00e1logas a los \"System Calls\" (llamadas al sistema) y nos permiten hacer cosas como imprimir a consola o reservar memoria din\u00e1mica.","title":"Cosas b\u00e1sicas en V-Sim:"},{"location":"labs/lab03/#ejercicio-1-familiarizandote-con-jupiter","text":"Para este ejercicio ustedes van a familiarizarse con Jupiter corriendo un programa sencillo de RISC-V y, luego, contestar\u00e1n unas preguntas. Abran una terminal ( CTRL + T ) y dir\u00edjanse a la carpeta del repositorio que clonaron. Abran el modo GUI de V-Sim ejecutando en la terminal jupiter . Desde el editor abran el archivo llamado ex1.s que esta en la carpeta ex1 . En la barra de herramientas de Jupiter, vayan a settings y aseg\u00farense de que Assemble Only Selected Tab est\u00e9 seleccionado con un cheque verde. Presionen F3 . Esto va a preparar el c\u00f3digo para que pueda ser ejecutado y simulado. Si hacen click a la pesta\u00f1a \"Editor\", su simulaci\u00f3n se va a reiniciar. En el simulador, para ejecutar la siguiente instrucci\u00f3n, presionen el bot\u00f3n que dice \"step\". Para regresar un paso atr\u00e1s, presionen el bot\u00f3n que dice \"backstep\". Para correr todo el programa hasta que termine, presionen el bot\u00f3n que dice \"go\". Para volver a empezar el programa nuevamente, presionen el bot\u00f3n que dice \"reset\". Para ver el contenido de los 32 registros en la parte derecha del simulador, hay una pesta\u00f1a que dice RVI . La consola est\u00e1 en la parte de abajo del simulador. Para ver el contenido de la memoria, en el mismo lugar que los registros hay una pesta\u00f1a que dice Memory , pueden navegar a diferentes secciones de la memoria haciendo click derecho encima de la tabla que muestra el estado de la memoria.","title":"Ejercicio 1: Familiariz\u00e1ndote con Jupiter"},{"location":"labs/lab03/#preguntas","text":"Ahora que ya han corrido su primer programa de RISC-V y que ganaron experiencia con Jupiter pueden contestar las siguientes preguntas en el archivo ex1.txt que se encuentra en la carpeta ex1 . 1) \u00bfQu\u00e9 significan las directivas .data , .word , .text , es decir, para qu\u00e9 las utilizan? Escriban s\u00f3lo una de las siguientes letras para responder. Pista: Piensen acerca de las cuatro secciones de memoria. A) Son como etiquetas sirven para hacer referencia a cosas que est\u00e1n en memoria, con .data apuntamos hacia los datos con .word hacia palabras de 32 bits y con .text hacia texto. B) .data le indica al ensamblador que guarde los siguientes elementos en la secci\u00f3n est\u00e1tica de la memoria, .word que guarde una palabra de 32 bits en memoria en la secci\u00f3n est\u00e1tica de datos y .text que estamos en la secci\u00f3n de texto y entonces deber\u00edamos escribir instrucciones de ensamblador. C) .data es para guardar datos en la secci\u00f3n de datos de la memoria, .word es para guardar palabras de 32 bits en la secci\u00f3n de palabras de la memoria, .text es para guardar texto ascii en la secci\u00f3n de texto de la memoria. D) .data y .word no son directivas de ensamblador, y .text siempre est\u00e1 por defecto y ni se tendr\u00eda que poner. 2) Corran por completo el programa. \u00bfQu\u00e9 n\u00famero da como \"output\"? 3) \u00bfQu\u00e9 representa el n\u00famero que da como output el programa? Escriban s\u00f3lo una de las siguientes letras para responder: A) N\u00famero \u00e1ureo B) Factorial de 9 C) Fibonnaci de 9 D) Factorial de 10 4) \u00bfEn qu\u00e9 direcci\u00f3n de memoria (en hexadecimal) est\u00e1 almacenado \"n\"? Pista: Miren el contenido de los registros. 5) Sin utilizar la pesta\u00f1a \"Editor\", hagan que el programa calcule el 13\u00ba n\u00famero (tomando en cuenta que el \u00edndice empieza en 0) de la sucesi\u00f3n de Fibonacci, modificando manualmente el valor de un registro. Encontrar\u00e1n \u00fatil de primero correr l\u00ednea por l\u00ednea el c\u00f3digo. Si prefieren ver los valores en decimal, cambien esto haciendo click derecho sobre la tabla de registros y presionando \"Decimal Display Mode\". \u00bfQu\u00e9 registro modificaron?","title":"Preguntas"},{"location":"labs/lab03/#ejercicio-2-traduciendo-de-c-a-risc-v","text":"Desde Jupiter abran el archivo ex2.s que est\u00e1 en la carpeta ex2 y, desde alg\u00fan editor de texto de su preferencia, abran ex2.c , que est\u00e1 en la misma carpeta. El c\u00f3digo ensamblador que se provee (archivo ex2.s) es una traducci\u00f3n del programa escrito en C (archivo ex2.c) pero en RISC-V. Su tarea es encontrar/explicar los siguientes componentes de este archivo escrito en lenguaje ensamblador en el archivo de texto llamado ex2.txt , que tambi\u00e9n est\u00e1 en la misma carpeta.","title":"Ejercicio 2: Traduciendo de C a RISC-V"},{"location":"labs/lab03/#preguntas_1","text":"\u00bfCu\u00e1l es el registro que representa la variable k ? \u00bfCu\u00e1les son los registros que act\u00faan como punteros a los arreglos source y dest (separados por coma)? \u00bfDe qu\u00e9 n\u00famero de l\u00ednea a que n\u00famero l\u00ednea se encuentra el loop (separado por coma)? \u00bfEn qu\u00e9 n\u00famero de l\u00ednea se copia el contenido de source a dest ?, es decir \u00bfd\u00f3nde se puede observar dest[k] = source[k] ?. \u00bfC\u00f3mo son manipulados los punteros en el c\u00f3digo? Escriban s\u00f3lo una de las siguientes letras para responder: A) En cada iteraci\u00f3n se le suma k a cada puntero, que es el equivalente en C a arreglo[k] . B) En cada iteraci\u00f3n se le suma k * 4 a cada puntero, que es equivalente en C a arreglo[k] . C) En cada iteraci\u00f3n se le hace corrimiento l\u00f3gico a la derecha a cada puntero, que es equivalente en C a arreglo[k] . D) En cada iteraci\u00f3n se le suma +1 a cada puntero, que es equivalente en C a arreglo[k] .","title":"Preguntas"},{"location":"labs/lab03/#ejercicio-3-factorial","text":"En este ejercicio, tienen que implementar la funci\u00f3n de factorial en RISC-V que toma un s\u00f3lo par\u00e1metro entero n y retorna n! . Pueden encontrar un esqueleto de esta funci\u00f3n en el archivo factorial.s , que se encuentra en la carpeta ex3 del repositorio que clonaron. Ustedes s\u00f3lo necesitan agregar las instrucciones bajo la etiqueta factorial , y el argumento que se pasa a la funci\u00f3n va en el registro a0 . Pueden resolver este problema ya sea de forma recursiva o iterativa. Aseg\u00farense de que su funci\u00f3n retorne de forma apropidada lo siguiente 3! = 6 , 7! = 5040 y 8! = 40320 .","title":"Ejercicio 3: Factorial."},{"location":"labs/lab03/#ejercicio-4-list-map","text":"Para este ejercicio van a utilizar el archivo list_map.s que se encuentra en la carpeta ex4 . En este ejercicio, van a completar una funci\u00f3n de \"map\" con listas encadenadas en RISC-V. La funci\u00f3n se simplificar\u00e1 en mutar la lista en cuesti\u00f3n, es decir que tomar\u00e1 una lista encadenada como entrada y va a retornar la lista con los valores modificados. Nuestro procedimiento de \"map\" toma dos par\u00e1metros, el primero ser\u00e1 la direcci\u00f3n del nodo \"head\" de una lista encadenada, cuyos valores son enteros de 32 bits. Entonces, en C, la estructura se define como: 1 2 3 4 struct node { int value ; struct node * next ; }; El segundo par\u00e1metro ser\u00e1 la direcci\u00f3n de una funci\u00f3n que toma un entero como argumento y devuelve un entero. Usaremos la instrucci\u00f3n \"jalr\" de RISC-V para llamar a esta funci\u00f3n con los valores de cada nodo de la lista. Nuestra funci\u00f3n \"map\" ir\u00e1 recorriendo la lista recursivamente, aplicando la funci\u00f3n a cada valor de la lista y almacenando el valor devuelto al nodo correspondiente. En C, la funci\u00f3n se ver\u00eda algo como esta: 1 2 3 4 5 void map ( struct node * head , int ( * f )( int )) { if ( ! head ) { return ; } head -> value = f ( head -> value ); map ( head -> next , f ); } Si no hab\u00edan visto lo de int (*f)(int) antes, no se preocupen demasiado. Significa b\u00e1sicamente que f es un puntero a una funci\u00f3n de C, f entonces puede ser utilizado exactamente como cualquier otra funci\u00f3n. Les ser\u00e1 \u00fatil acudir al green card de RISC-V que pueden encontrar aqu\u00ed para completar este ejercicio. Hay exactamente 9 espacios (8 en map y 1 en main ), en el c\u00f3digo que se provee, donde dice YOUR_INSTRUCTION_HERE . Reemplacen esos espacios con las instrucciones de su implementaci\u00f3n de map, y escriban una simple llamada a map con square como argumento de la funci\u00f3n. Hay comentarios en el c\u00f3digo que explican qu\u00e9 deber\u00eda hacer, o cumplir, cada instrucci\u00f3n. Cuando hayan rellenado los espacios con las instrucciones correctas, pueden correr el c\u00f3digo pulsando en F3 y luego el bot\u00f3n Go , al hacer esto, deber\u00eda de darles como output lo siguiente: 1 2 9 8 7 6 5 4 3 2 1 0 81 64 49 36 25 16 9 4 1 0 La primera l\u00ednea es la lista original, y la segunda es la lista modificada despu\u00e9s de que se aplic\u00f3 la funci\u00f3n \"map\".","title":"Ejercicio 4: List Map"},{"location":"labs/lab03/#calificacion","text":"Por favor actualizar siempre la versi\u00f3n del CLI de autograders: 1 pip3 install --upgrade autograders-cli Como en todos los dem\u00e1s laboratorios, hay un autograder y este no es la excepci\u00f3n. El staff trabajo bastante para que su experiencia en este curso sea de las mejores. Entregaremos este lab de la misma manera que el pasado. Navegue hacia la carpeta donde tiene sus archivos, haga un ls y asegurese que le aparece el archivo autograders.json; si aparecio, esta en el lugar correcto. Ahora puede entregar su laboratorio con... 1 autograder --upload Espera un minuto aprox. y luego puede ver sus resultados con... 1 autograder --stats Si le aparece Queued: True, espere un par de minutos y luego repita el autograder --stats \u00fanicamente. Al terminar todo, suba el link de su repositorio al GES.","title":"Calificaci\u00f3n"},{"location":"tutorials/install/","text":"Tutorial de Instalaci\u00f3n de Material El objetivo de este tutorial es dejar preparado el material que necesitar\u00e1n para los laboratorios y proyectos. La mejor opci\u00f3n: M\u00e1quina virtual Descarguen la siguiente m\u00e1quina virtual y \u00e1branla con VMware. Recuerde que usando VMware Player (gratuito, sin necesidad de licencia) puede abrir y utilizar m\u00e1quinas virtuales ya hechas. Todos los links son para la misma m\u00e1quina virtual. Si alguno falla, utilicen otro. Descargar m\u00e1quina virtual desde Google Drive Descargar m\u00e1quina virtual desde Google Drive (mirror) Descargar m\u00e1quina virtual desde Mega Credenciales Usuario : student Password : student La m\u00e1quina virtual ya trae todo lo necesario para el semestre. Instalaci\u00f3n Nativa Para trabajar nativo necesitar\u00e1n Ubuntu 16 o 18 en ingl\u00e9s, se recomienda 18. En Ubuntu 20 no podr\u00e1n utilizar Jupiter. Si su Ubuntu no se encuentra en ingl\u00e9s, tendra problemas en el lab 2 (cgdb). Puede cambiar su idioma, o buscar la soluci\u00f3n al problema en Google. Si todav\u00eda no tiene Ubuntu instalado aqu\u00ed hay un tutorial para dual boot . Ponga mucha atenci\u00f3n, sea muy cuidadoso y sobre todo haga un backup de su informaci\u00f3n importante. Wow... parece que son bastantes instrucciones, \u00a1Ser\u00eda m\u00e1s f\u00e1cil usar la m\u00e1quina virtual! Instalar git 1 2 sudo apt update sudo apt install git Instalar Java 1 2 sudo apt update sudo apt install default-jdk Instalar Python 3 1 2 3 4 5 sudo apt update sudo apt install software-properties-common sudo add-apt-repository ppa:deadsnakes/ppa sudo apt update sudo apt install python3.7 Instalar pip 1 2 sudo apt update sudo apt install python3-pip Las versiones recientes de Python suelen incluir todo lo que necesitamos (en la maquina virtual ya revisamos y esta todo lo que necesita! en serio, use la m\u00e1quina virtual!), verifiqu\u00e9moslo abriendo la terminal de Python con el comando python3 , luego en la terminal escribiremos los siguientes comandos 1 2 3 4 import os import sys import requests import zipfile Si ninguno nos dio problema, Python esta listo; si alguno fallo, lo instalaremos con pip 1 pip3 install nombreDelPaqueteQueDioError cURL Finalmente instalamos curl 1 2 sudo apt update sudo apt install curl CGDB Y terminamos instalando cgdb 1 2 sudo apt update sudo apt install cgdb Casi listo! Cuando lleguemos al lab 3 y al lab 5 alli le aparecer\u00e1n las instrucciones para instalar el software faltante. Mi computadora no es muy potente, \u00bfQu\u00e9 puedo hacer? Puede probar con algun IDE en l\u00ednea como repl.it . Aqu\u00ed podr\u00e1 trabajar un poco de C y entregar su lab 0 y lab 1, pero al llegar al lab 2 comienzan los problemas. Estamos tratando de buscar herramientas para trabajar en l\u00ednea, pero haga todo lo posible por trabajar ya sea en m\u00e1quina virtual o en Ubuntu nativo. Soy demasiado fan\u00e1tico de Windows 10, \u00bfhay alguna opci\u00f3n para m\u00ed? Puede instalar WSL en su m\u00e1quina. Luego de ese mont\u00f3n de pasos, tendr\u00e1 que instalar todo el material de arriba. No haga esto, mejor use la m\u00e1quina virtual. Esta es una opci\u00f3n que no aconsejamos para nada. Si esta en Windows, no le podremos ayudar con sus problemas, solo le sugeriremos que... \u00a1adivin\u00f3! use la m\u00e1quina virtual.","title":"Instalaci\u00f3n VM"},{"location":"tutorials/install/#tutorial-de-instalacion-de-material","text":"El objetivo de este tutorial es dejar preparado el material que necesitar\u00e1n para los laboratorios y proyectos.","title":"Tutorial de Instalaci\u00f3n de Material"},{"location":"tutorials/install/#la-mejor-opcion-maquina-virtual","text":"Descarguen la siguiente m\u00e1quina virtual y \u00e1branla con VMware. Recuerde que usando VMware Player (gratuito, sin necesidad de licencia) puede abrir y utilizar m\u00e1quinas virtuales ya hechas. Todos los links son para la misma m\u00e1quina virtual. Si alguno falla, utilicen otro. Descargar m\u00e1quina virtual desde Google Drive Descargar m\u00e1quina virtual desde Google Drive (mirror) Descargar m\u00e1quina virtual desde Mega","title":"La mejor opci\u00f3n: M\u00e1quina virtual"},{"location":"tutorials/install/#credenciales","text":"Usuario : student Password : student La m\u00e1quina virtual ya trae todo lo necesario para el semestre.","title":"Credenciales"},{"location":"tutorials/install/#instalacion-nativa","text":"Para trabajar nativo necesitar\u00e1n Ubuntu 16 o 18 en ingl\u00e9s, se recomienda 18. En Ubuntu 20 no podr\u00e1n utilizar Jupiter. Si su Ubuntu no se encuentra en ingl\u00e9s, tendra problemas en el lab 2 (cgdb). Puede cambiar su idioma, o buscar la soluci\u00f3n al problema en Google. Si todav\u00eda no tiene Ubuntu instalado aqu\u00ed hay un tutorial para dual boot . Ponga mucha atenci\u00f3n, sea muy cuidadoso y sobre todo haga un backup de su informaci\u00f3n importante. Wow... parece que son bastantes instrucciones, \u00a1Ser\u00eda m\u00e1s f\u00e1cil usar la m\u00e1quina virtual!","title":"Instalaci\u00f3n Nativa"},{"location":"tutorials/install/#instalar-git","text":"1 2 sudo apt update sudo apt install git","title":"Instalar git"},{"location":"tutorials/install/#instalar-java","text":"1 2 sudo apt update sudo apt install default-jdk","title":"Instalar Java"},{"location":"tutorials/install/#instalar-python-3","text":"1 2 3 4 5 sudo apt update sudo apt install software-properties-common sudo add-apt-repository ppa:deadsnakes/ppa sudo apt update sudo apt install python3.7","title":"Instalar Python 3"},{"location":"tutorials/install/#instalar-pip","text":"1 2 sudo apt update sudo apt install python3-pip Las versiones recientes de Python suelen incluir todo lo que necesitamos (en la maquina virtual ya revisamos y esta todo lo que necesita! en serio, use la m\u00e1quina virtual!), verifiqu\u00e9moslo abriendo la terminal de Python con el comando python3 , luego en la terminal escribiremos los siguientes comandos 1 2 3 4 import os import sys import requests import zipfile Si ninguno nos dio problema, Python esta listo; si alguno fallo, lo instalaremos con pip 1 pip3 install nombreDelPaqueteQueDioError","title":"Instalar pip"},{"location":"tutorials/install/#curl","text":"Finalmente instalamos curl 1 2 sudo apt update sudo apt install curl","title":"cURL"},{"location":"tutorials/install/#cgdb","text":"Y terminamos instalando cgdb 1 2 sudo apt update sudo apt install cgdb Casi listo! Cuando lleguemos al lab 3 y al lab 5 alli le aparecer\u00e1n las instrucciones para instalar el software faltante.","title":"CGDB"},{"location":"tutorials/install/#mi-computadora-no-es-muy-potente-que-puedo-hacer","text":"Puede probar con algun IDE en l\u00ednea como repl.it . Aqu\u00ed podr\u00e1 trabajar un poco de C y entregar su lab 0 y lab 1, pero al llegar al lab 2 comienzan los problemas. Estamos tratando de buscar herramientas para trabajar en l\u00ednea, pero haga todo lo posible por trabajar ya sea en m\u00e1quina virtual o en Ubuntu nativo.","title":"Mi computadora no es muy potente, \u00bfQu\u00e9 puedo hacer?"},{"location":"tutorials/install/#soy-demasiado-fanatico-de-windows-10-hay-alguna-opcion-para-mi","text":"Puede instalar WSL en su m\u00e1quina. Luego de ese mont\u00f3n de pasos, tendr\u00e1 que instalar todo el material de arriba. No haga esto, mejor use la m\u00e1quina virtual. Esta es una opci\u00f3n que no aconsejamos para nada. Si esta en Windows, no le podremos ayudar con sus problemas, solo le sugeriremos que... \u00a1adivin\u00f3! use la m\u00e1quina virtual.","title":"Soy demasiado fan\u00e1tico de Windows 10, \u00bfhay alguna opci\u00f3n para m\u00ed?"}]}